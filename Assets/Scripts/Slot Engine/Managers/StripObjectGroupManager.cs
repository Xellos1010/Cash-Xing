//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Reel.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
using System.Collections.Generic;
using System;

namespace BoomSports.Prototype.Managers
{
#if UNITY_EDITOR
    using UnityEditor;
    public enum eEaseType
    {
        linear,
        constant,
        ease
    }


    [CanEditMultipleObjects]
    [CustomEditor(typeof(StripObjectGroupManager))]
    class ReelStripManagerEditor : BoomSportsEditor
    {
        StripObjectGroupManager myTarget;
        int selectedSymbolToGenerate = 0;
        public void OnEnable()
        {
            myTarget = (StripObjectGroupManager)target;
        }

        public override void OnInspectorGUI()
        {
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("Controls");
            if(!Application.isPlaying)
            {
                if (GUILayout.Button("print ABS sqr magnitude of positions 1 and 3 and offset"))
                {
                    Debug.Log($"ABS sqrmagnitude of localPositionsInStrip[0] = {Mathf.Abs(myTarget.localPositionsInStrip[0].sqrMagnitude)}");
                    Debug.Log($"ABS sqrmagnitude of localPositionsInStrip[0] + offset = {Mathf.Abs((myTarget.localPositionsInStrip[0] + (Vector3.back * 10)).sqrMagnitude)}");
                    Debug.Log($"ABS sqrmagnitude of localPositionsInStrip[0] = {myTarget.localPositionsInStrip[0].sqrMagnitude}");
                    Debug.Log($"ABS sqrmagnitude of localPositionsInStrip[0] + offset = {(myTarget.localPositionsInStrip[0] + (Vector3.back * 10)).sqrMagnitude}");
                    Debug.Log($"ABS sqrmagnitude of localPositionsInStrip[2] = {Mathf.Abs(myTarget.localPositionsInStrip[2].sqrMagnitude)}");
                    Debug.Log($"ABS sqrmagnitude of localPositionsInStrip[2] + offset = {Mathf.Abs((myTarget.localPositionsInStrip[2] + (Vector3.back * 10)).sqrMagnitude)}");
                }

                if(GUILayout.Button("Test OoO(Order of Operations) for Start Spin"))
                {
                    //Initialize Padding slot start position - Ensure graphic of padding slot set to next graphic in sequence
                    myTarget.InitializePaddingSlotPositionAndSymbol();
                    //Clear Ending Symbols - Set new ending symbols
                    myTarget.InitializeEndDisplaySequenceToSet();
                    //Switching to ObjectManager of spin object to invoke check of display symbol and row in strip.
                    //Check each symbols next position - any symbol activating a condition send event to recieving object
                    //Cash Crossing when a bonus symbol enters a slot it sends idle trigger to associated bridge animator
                    myTarget.InitializeConditionalEvents();
                    myTarget.CheckForConditionalEventsFromEndDisplaySequence(myTarget.symbolsDisplaySequence);
                }
                if (GUILayout.Button("Set Intial Padding Slot object"))
                {
                    myTarget.paddingSlot = myTarget.objectsInGroup[0];
                }
                if (GUILayout.Button("Set Local Positions To Slot Current Positions"))
                {
                    myTarget.SetLocalPositionsBySlotPositions();
                }
                if (GUILayout.Button("Set Index on path for objects"))
                {
                    myTarget.SetPositionIndexOnPathForObjects();
                }
                if (GUILayout.Button("Set Next Display symbols sequence based on spin type"))
                {
                    myTarget.InitializeEndDisplaySequenceToSet();
                }
                if (GUILayout.Button("Set Slot Positions To Initial Local Positions"))
                {
                    myTarget.SetSlotPositionToStart();
                }
                if (GUILayout.Button("Update sub state machines slot managers"))
                {
                    myTarget.UpdateSlotManagersSubStateMachines();
                }
            }
            if (myTarget.isSpinning)
            {
                if (GUILayout.Button("Spin Reel Test"))
                {
                    myTarget.SpinGroupNowTestNoAnimator(true);
                }
                if (GUILayout.Button("Stop Reel Test"))
                {
                    myTarget.StopReel();
                }
            }
            else
            {
                if (GUILayout.Button("Enable Movement"))
                {
                    myTarget.SetSlotsMovementEnabled(true);
                }
                if (GUILayout.Button("Disable Movement"))
                {
                    myTarget.SetSlotsMovementEnabled(false);
                }
            }
            GUILayout.BeginHorizontal();
            selectedSymbolToGenerate = EditorGUILayout.Popup(selectedSymbolToGenerate, myTarget.configurationObjectParent.supportedSymbols);
            GUILayout.EndHorizontal();
            if (GUILayout.Button("Set Next Symbol to Appear On Reel To:"))
            {
                myTarget.SetNextSymbolToSetOnLoopPath(selectedSymbolToGenerate);
            }
            BoomEditorUtilities.DrawUILine(Color.white);
            base.OnInspectorGUI();
        }
    }

#endif

    public class StripObjectGroupManager : BaseObjectGroupManager
    {
        internal BaseConfigurationObjectManager configurationObjectParent
        {
            get
            {
                if (base.configurationObjectParent == null)
                    base.configurationObjectParent = transform.GetComponentInParent<BaseConfigurationObjectManager>();
                return base.configurationObjectParent;
            }
        }
        /// <summary>
        /// Holds the reference for the slots position in path from entering to exiting reel area
        /// </summary>
        [SerializeField]
        internal Vector3[] localPositionsInStrip;
        /*
////For Spinning down the yCurve needs to be set for each
///// <summary>
///// start spin easing
///// </summary>
//public AnimationCurve[] start_spin_curve_xyz
//{
//    get
//    {
//        if (_start_spin_curve_xyz == null || _start_spin_curve_xyz.Length < 3)
//        {
//            _start_spin_curve_xyz = new AnimationCurve[3] {
//            AnimationCurve.Linear(0.0f,0,1,reel_spin_speed_direction.magnitude),
//            AnimationCurve.Linear(0.0f,0,1,reel_spin_speed_direction.magnitude),
//            AnimationCurve.Linear(0.0f,0,1,reel_spin_speed_direction.magnitude)
//            };
//        }
//        return _start_spin_curve_xyz;
//    }
//    set
//    {
//        _start_spin_curve_xyz = value;
//    }
//}
////Eases the speed over seconds
///// <summary>
///// Looping Path Time - slot 0 -> end slot - each key is a position in path. Speed - Speed -> pixels to move per Time.deltatime / seconds
///// </summary>
//public AnimationCurve[] looping_curves_xyz
//{
//    get
//    {
//        if (_looping_curves_xyz == null || _looping_curves_xyz.Length < 3)
//        {
//            _looping_curves_xyz = new AnimationCurve[3] {
//            AnimationCurve.Constant(0.0f,0.0f,reel_spin_speed_direction.magnitude), //todo calculate time to move over position in path v#
//            AnimationCurve.Constant(0.0f,0.0f,reel_spin_speed_direction.magnitude),
//            AnimationCurve.Constant(0.0f,0.0f,reel_spin_speed_direction.magnitude)
//            };
//        }
//        return _looping_curves_xyz;
//    }
//    set
//    {
//        _looping_curves_xyz = value;
//    }
//}

/// <summary>
/// end spin easing
/// </summary>
//public AnimationCurve[] end_spin_curve_xyz;
*/
        /// <summary>
        /// Draws debug GUI for User to see data in action
        /// </summary>
        public void OnDrawGizmos()
        {
            //Uncomment to see local positions reference for positions_in_path
            DrawDebugForPositionsOnPath();
        }    
        /// <summary>
        /// Used to draw positions in path
        /// </summary>
        private void DrawDebugForPositionsOnPath()
        {
            if(localPositionsInStrip != null)
            { 
            if (localPositionsInStrip.Length > 0)
                {
                    for (int i = 0; i < localPositionsInStrip.Length; i++)
                    {
                        if (i == 0)
                            Gizmos.DrawSphere(transform.TransformPoint(localPositionsInStrip[i]), 25f);//String.Format("Slot Start Position {0}", i));
                        else if (i == (localPositionsInStrip.Length - 1))
                            Gizmos.DrawSphere(transform.TransformPoint(localPositionsInStrip[i]), 25f);//String.Format("Slot End Position {0}", i));
                        else
                            Gizmos.DrawSphere(transform.TransformPoint(localPositionsInStrip[i]), 25f);//String.Format("Slot Display Position {0}", i));
                    }
                }
            }
        }
        /// <summary>
        /// Return Spin Parameters from Configuration Settings
        /// </summary>
        /// <returns></returns>
        internal BasePathTransformSpinEvaluatorScriptableObject GetSpinParameters()
        {
            return configurationObjectParent.configurationSettings.displayZones[indexInGroupManager].spinParameters;
        }

        ///// <summary>
        ///// Get Initial Strip Positions from Configuration Settings
        ///// </summary>
        //internal void UpdateStripPositionsFromConfigurationSettings()
        //{
        //    Debug.LogWarning($"reelstrip_info.total_positions = {stripInfo.totalPositionsIngroup} reelstrip_info.total_slot_objects = {stripInfo.totalObjectsInGroup}");
        //    UpdateLocalPositionsInPath(stripInfo.totalPositionsIngroup);
        //}

        /// <summary>
        /// updates number of positions to store reference for based on reel length
        /// </summary>
        /// <param name="positions_to_generate_path_for">how many slots in reelstrip to save position reference</param>
        private void UpdateLocalPositionsInPath(int positions_to_generate_path_for)
        {
            //Setup the positions the slot will hit along path. Based on size and padding
            localPositionsInStrip = new Vector3[positions_to_generate_path_for]; //Spin into empty slots then move to top
            //get slots_in_reel: destroy slots if to many - add slots if to few
            for (int position_in_reel = 0; position_in_reel < localPositionsInStrip.Length; position_in_reel++)
            {
                localPositionsInStrip[position_in_reel] = GetSlotPositionInStrip(position_in_reel);
                //Debug.LogWarning($"positions_in_path_v3_local[position_in_reel] Generated for strip {gameObject.name} = {positions_in_path_v3_local[position_in_reel].ToString()}");
            }
        }

        internal bool AreSlotsInEndPosition()
        {
            bool output = false;
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                if(objectsInGroup[i].objectInEndPosition)
                {
                    if (i == objectsInGroup.Length - 1)
                        output = true;
                }
            }
            return output;
        }
        ////Generate the strip in the direction and calculate based on slot size x y
        //internal override void GenerateLocalPositions(ConfigurationSettingsScriptableObject configurationSettings)
        //{
        //    localPositionsInStrip = new Vector3[]
        //}

        internal override List<BaseObjectManager> GetSlotsDecending()
        {
            List<BaseObjectManager> output = new List<BaseObjectManager>();
            //Debug.Log($"localPositionsInStrip.Length == {localPositionsInStrip.Length} - objectsInGroup.Length == {objectsInGroup.Length}");
            //spinAtIndexInPath starts at 0 - at some point it is switched to index in path then after a few spins returns to 0.
            //when spinAtIndexInPath > 0 then the slot last moved to top (paddingSlot) at localPositionsInStrip[0] on spin start is initialized and shifted below localPositionsInStrip[spinAtIndexInPath] + (0,0,-20) - need to ensure symbol is set to symbol in sequence. will pull from debug symbol sequence for right now. Need to add padding slot to top of slots array passed to evaluator - evaluator does including padding slots as inactive evaluation row
            //during spin at index slots will place themselves at localPositionsInStrip[spinAtIndexInPath] + (0,0,-20) and use the next display symbol in sequence
            //Once all debug symbols to display in sequence is empty then spinAtIndexInPath is set to 0 

            for (int position_to_check = 0; position_to_check < localPositionsInStrip.Length; position_to_check++)
            {
                for (int slot = 0; slot < objectsInGroup.Length; slot++)
                {
                    //Debug.Log($"objectsInGroup[{slot}].transform.localPosition {objectsInGroup[slot].transform.localPosition} == {localPositionsInStrip[position_to_check]} localPositionsInStrip[position_to_check] is {objectsInGroup[slot].transform.localPosition == localPositionsInStrip[position_to_check]}");
                    if (objectsInGroup[slot].transform.localPosition == localPositionsInStrip[position_to_check])
                        output.Add(objectsInGroup[slot]);
                }
            }
            //for (int i = 0; i < output.Count; i++)
            //{
            //    Debug.Log($"{gameObject.name}.GetSlotsDecending()[{i}]{output[i].gameObject.name}.currentPresentingSymbolID = {output[i].currentPresentingSymbolID}");
            //}
            //Auto Adds padding slot when not in initial position - Uncomment will cause bugs if calling objects handle this logic (BaseObjectGroupManager)
            //if(output.Count != objectsInGroup.Length)
            //{
            //    Debug.Log($"output.Count = {output.Count} objectsInGroup.Length = {objectsInGroup.Length}");
            //    //Find the slot with offset amount and what point in path is closest to slot
            //    for (int i = 0; i < objectsInGroup.Length; i++)
            //    {
            //        if(!output.Contains(objectsInGroup[i]))
            //        {
            //            Debug.Log($"!output.Contains({objectsInGroup[i].gameObject.name})");
            //            int closestPositionIndex = FindCloseestPositionTo(objectsInGroup[i]);
            //            output.Insert(closestPositionIndex, objectsInGroup[i]);
            //        }
            //    }
            //}
            //If spin at index on path is != 0 then 1 symbol will be set to position in path + (0,0,-x) need to grab that symbol and inject that as the next symbol in path (index at path will move down by 1)
            return output;
        }

        private int FindCloseestPositionTo(BaseObjectManager baseObjectManager)
        {
            int output = 0;
            Vector3 leastDistanceToObject = localPositionsInStrip[0] - baseObjectManager.transform.localPosition;
            Vector3 temp;
            for (int i = 1; i < localPositionsInStrip.Length; i++)
            {
                temp = localPositionsInStrip[i] - baseObjectManager.transform.localPosition;
                Debug.Log($"leastDistanceToObject.sqrMagnitude = {leastDistanceToObject.sqrMagnitude}\ntemp.sqrMagnitude = {temp.sqrMagnitude}\ntemp.sqrMagnitude < leastDistanceToObject.sqrMagnitude = {temp.sqrMagnitude < leastDistanceToObject.sqrMagnitude}");
                if (temp.sqrMagnitude < leastDistanceToObject.sqrMagnitude)
                {
                    leastDistanceToObject = temp;
                    output = i;
                }
            }
            return output;
        }

        private object PrintSlotObjectNames(StripObjectManager[] slotsList)
        {
            List<string> output = new List<string>();
            for (int slot = 0; slot < slotsList.Length; slot++)
            {
                output.Add(slotsList[slot].gameObject.name);
            }
            return String.Join("|", output);
        }

        internal NodeDisplaySymbolContainer ReturnNextSymbolInStrip()
        {
            int stripCounter = 0;
            NodeDisplaySymbolContainer output = groupInfo.spinInformation.spinIdleSymbolSequence[stripCounter];
            if (stripCounter + 1 >= groupInfo.spinInformation.spinIdleSymbolSequence.Length)
            {
                stripCounter = 0;
            }
            else
            {
                stripCounter += 1;
            }
            return output;
        }

        internal int GetIndexOfEndSymbolsStartInStrip()
        {
            return GetSymbolsToBeReplacedPerSpin(); //Stepper Reel

            //if (symbolsDisplaySequence.Length > configurationGroupDisplayZones.displayZonesPositionsTotal)
            //{
            //    return GetSymbolsToBeReplacedPerSpin(); //Stepper Reel
            //}
            //else
            //{
            //    return symbolsDisplaySequence.Length - 1;
            //}
        }


        /// <summary>
        /// Generates a position for a slot in reel
        /// </summary>
        /// <param name="positionInStrip">Position in Reel slot will be</param>
        /// <returns>Slot Position Vector3</returns>
        internal Vector3 GetSlotPositionInStrip(int positionInStrip)
        {
            //TODO Base on Spin Direction
            //Debug.Log(String.Format("reelstrip_info.reel_number = {0} slot size = ({1},{2}) matrix padding.x = {3}", stripInfo.stripColumn, configurationObjectParent.configurationSettings.slotSize.x, configurationObjectParent.configurationSettings.slotSize.y, configurationObjectParent.configurationSettings.slotPadding.x));
            float x = 0;//reelstrip_info.reel_number * (matrix.configurationSettings.slotSize.x + matrix.configurationSettings.slotPadding.x);//Uncomment to set slot position at slot level
            float y = -(positionInStrip * (configurationObjectParent.configurationSettings.slotSize.y + configurationObjectParent.configurationSettings.slotPadding.y));
            //Debug.Log(string.Format("Local Position for slot {0} int reel {1} is ({2},{3},{4}) ",positionInStrip, transform.name,x.ToString(), y.ToString(),0));
            Vector3 return_position = new Vector3(x, y, 0);
            return return_position;
        }

        /// <summary>
        /// Sets the slots as referenced to the position in the reel
        /// </summary>
        internal void SetSlotPositionToStart()
        {
            //Debug.Log($"Setting positions to start {gameObject.name}");
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].transform.localPosition = localPositionsInStrip[i];
            }
        }

        internal void ClearObjectsInStrip()
        {
            for (int i = transform.childCount - 1; i >= 0; i--)
                Destroy(transform.GetChild(i).gameObject);
        }
        /// <summary>
        /// Sets all slot managers sub state machines to trigger and set bools
        /// </summary>
        internal void UpdateSlotManagersSubStateMachines()
        {
            for (int i = 0; i < objectsInGroup?.Length; i++)
            {
                objectsInGroup[i].SetSubStateMachineAnimators();
                objectsInGroup[i].SetAllSubSymbolsGameobjectActive();
            }
            configurationObjectParent._managers.endConfigurationManager.SetMatrixToReelConfiguration();
        }

        internal void InitializeLocalPositions()
        {
            Debug.Log($"{gameObject.name} Initializing local positions for displayZone.totalPositions {configurationGroupDisplayZones.totalPositions}");
            localPositionsInStrip = new Vector3[configurationGroupDisplayZones.totalPositions];
            for (int i = 0; i < localPositionsInStrip.Length; i++)
            {
                localPositionsInStrip[i] = GetSlotPositionInStrip(i);
            }
            Debug.Log($"localPositionsInStrip.Lengh = {localPositionsInStrip.Length}");
        }

        internal void SetLocalPositionsBySlotPositions()
        {
            if(localPositionsInStrip.Length < objectsInGroup.Length+1)
            {
                Debug.LogWarning($"localPositionsInStrip.Length {localPositionsInStrip.Length} < objectsInGroup.Length {objectsInGroup.Length + 1} = {localPositionsInStrip.Length < objectsInGroup.Length+1} creating new array to fill - You need to set the end position - you have been warned");
                localPositionsInStrip = new Vector3[objectsInGroup.Length + 1];
            }
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                localPositionsInStrip[slot] = objectsInGroup[slot].transform.localPosition;
            }
        }

        internal void SetPositionIndexOnPathForObjects()
        {
            for (int groupedObject = 0; groupedObject < objectsInGroup.Length; groupedObject++)
            {
                objectsInGroup[groupedObject].SetIndexOnPathfromCurrentPosition(ref localPositionsInStrip);
            }
        }
    }
}
