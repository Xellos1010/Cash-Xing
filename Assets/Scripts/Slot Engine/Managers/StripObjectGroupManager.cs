//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Reel.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
using System.Collections.Generic;
using System;

namespace BoomSports.Prototype.Managers
{
#if UNITY_EDITOR
    using UnityEditor;
    public enum eEaseType
{
    constant,
    ease,
}


    [CanEditMultipleObjects]
    [CustomEditor(typeof(StripObjectGroupManager))]
    class ReelStripManagerEditor : BoomSportsEditor
    {
        StripObjectGroupManager myTarget;
        int selectedSymbolToGenerate = 0;
        public void OnEnable()
        {
            myTarget = (StripObjectGroupManager)target;
        }

        public override void OnInspectorGUI()
        {
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("Controls");
            if(!Application.isPlaying)
            {
                if(GUILayout.Button("Set Local Positions To Slot Current Positions"))
                {
                    myTarget.SetLocalPositionsBySlotPositions();
                }
                if (GUILayout.Button("Set positions on path for objects"))
                {
                    myTarget.SetPositionIndexOnPathForObjects();
                }
                if (GUILayout.Button("Set Slot Positions To Initial Local Positions"))
                {
                    myTarget.SetSlotPositionToStart();
                }
                //if (GUILayout.Button("Update Slot objects and positions local world reference"))
                //{
                //    myTarget.UpdateStripPositionsFromConfigurationSettings();
                //}
                if (GUILayout.Button("Update sub state machines slot managers"))
                {
                    myTarget.UpdateSlotManagersSubStateMachines();
                }
            }
            if (myTarget.isSpinning)
            {
                if (GUILayout.Button("Spin Reel Test"))
                {
                    myTarget.SpinGroupNow(true);
                }
            }
            else
            {
                if (GUILayout.Button("Enable Movement"))
                {
                    myTarget.SetSlotsMovementEnabled(true);
                }
                if (GUILayout.Button("Disable Movement"))
                {
                    myTarget.SetSlotsMovementEnabled(false);
                }
            }
            GUILayout.BeginHorizontal();
            selectedSymbolToGenerate = EditorGUILayout.Popup(selectedSymbolToGenerate, myTarget.configurationObjectParent.supportedSymbols);
            GUILayout.EndHorizontal();
            if (GUILayout.Button("Set Next Symbol to Appear On Reel To:"))
            {
                myTarget.SetNextSymbolToSetOnLoopPath(selectedSymbolToGenerate);
            }
            BoomEditorUtilities.DrawUILine(Color.white);
            base.OnInspectorGUI();
        }
    }

#endif

    public class StripObjectGroupManager : BaseObjectGroupManager
    {
        //the matrix associated with the reel_strip
        internal BaseConfigurationObjectManager configurationObjectParent
        {
            get
            {
                if (base.configurationObjectParent == null)
                    base.configurationObjectParent = transform.GetComponentInParent<BaseConfigurationObjectManager>();
                return base.configurationObjectParent;
            }
        }
        [SerializeField]
        internal GroupInformationStruct stripInfo;
        /// <summary>
        /// Holds the reference for the slots position in path from entering to exiting reel area
        /// </summary>
        [SerializeField]
        internal Vector3[] localPositionsInStrip;
        /*
////For Spinning down the yCurve needs to be set for each
///// <summary>
///// start spin easing
///// </summary>
//public AnimationCurve[] start_spin_curve_xyz
//{
//    get
//    {
//        if (_start_spin_curve_xyz == null || _start_spin_curve_xyz.Length < 3)
//        {
//            _start_spin_curve_xyz = new AnimationCurve[3] {
//            AnimationCurve.Linear(0.0f,0,1,reel_spin_speed_direction.magnitude),
//            AnimationCurve.Linear(0.0f,0,1,reel_spin_speed_direction.magnitude),
//            AnimationCurve.Linear(0.0f,0,1,reel_spin_speed_direction.magnitude)
//            };
//        }
//        return _start_spin_curve_xyz;
//    }
//    set
//    {
//        _start_spin_curve_xyz = value;
//    }
//}
////Eases the speed over seconds
///// <summary>
///// Looping Path Time - slot 0 -> end slot - each key is a position in path. Speed - Speed -> pixels to move per Time.deltatime / seconds
///// </summary>
//public AnimationCurve[] looping_curves_xyz
//{
//    get
//    {
//        if (_looping_curves_xyz == null || _looping_curves_xyz.Length < 3)
//        {
//            _looping_curves_xyz = new AnimationCurve[3] {
//            AnimationCurve.Constant(0.0f,0.0f,reel_spin_speed_direction.magnitude), //todo calculate time to move over position in path v#
//            AnimationCurve.Constant(0.0f,0.0f,reel_spin_speed_direction.magnitude),
//            AnimationCurve.Constant(0.0f,0.0f,reel_spin_speed_direction.magnitude)
//            };
//        }
//        return _looping_curves_xyz;
//    }
//    set
//    {
//        _looping_curves_xyz = value;
//    }
//}

/// <summary>
/// end spin easing
/// </summary>
//public AnimationCurve[] end_spin_curve_xyz;
*/
        /// <summary>
        /// Draws debug GUI for User to see data in action
        /// </summary>
        public void OnDrawGizmos()
        {
            //Uncomment to see local positions reference for positions_in_path
            DrawDebugForPositionsOnPath();
        }    
        /// <summary>
        /// Used to draw positions in path
        /// </summary>
        private void DrawDebugForPositionsOnPath()
        {
            if(localPositionsInStrip != null)
            { 
            if (localPositionsInStrip.Length > 0)
                {
                    for (int i = 0; i < localPositionsInStrip.Length; i++)
                    {
                        if (i == 0)
                            Gizmos.DrawSphere(transform.TransformPoint(localPositionsInStrip[i]), 25f);//String.Format("Slot Start Position {0}", i));
                        else if (i == (localPositionsInStrip.Length - 1))
                            Gizmos.DrawSphere(transform.TransformPoint(localPositionsInStrip[i]), 25f);//String.Format("Slot End Position {0}", i));
                        else
                            Gizmos.DrawSphere(transform.TransformPoint(localPositionsInStrip[i]), 25f);//String.Format("Slot Display Position {0}", i));
                    }
                }
            }
        }
        /// <summary>
        /// Return Spin Parameters from Configuration Settings
        /// </summary>
        /// <returns></returns>
        internal BasePathTransformSpinEvaluatorScriptableObject GetSpinParameters()
        {
            return configurationObjectParent.configurationSettings.displayZones[indexInGroupManager].spinParameters;
        }

        ///// <summary>
        ///// Get Initial Strip Positions from Configuration Settings
        ///// </summary>
        //internal void UpdateStripPositionsFromConfigurationSettings()
        //{
        //    Debug.LogWarning($"reelstrip_info.total_positions = {stripInfo.totalPositionsIngroup} reelstrip_info.total_slot_objects = {stripInfo.totalObjectsInGroup}");
        //    UpdateLocalPositionsInPath(stripInfo.totalPositionsIngroup);
        //}

        /// <summary>
        /// updates number of positions to store reference for based on reel length
        /// </summary>
        /// <param name="positions_to_generate_path_for">how many slots in reelstrip to save position reference</param>
        private void UpdateLocalPositionsInPath(int positions_to_generate_path_for)
        {
            //Setup the positions the slot will hit along path. Based on size and padding
            localPositionsInStrip = new Vector3[positions_to_generate_path_for]; //Spin into empty slots then move to top
            //get slots_in_reel: destroy slots if to many - add slots if to few
            for (int position_in_reel = 0; position_in_reel < localPositionsInStrip.Length; position_in_reel++)
            {
                localPositionsInStrip[position_in_reel] = GetSlotPositionInStrip(position_in_reel);
                //Debug.LogWarning($"positions_in_path_v3_local[position_in_reel] Generated for strip {gameObject.name} = {positions_in_path_v3_local[position_in_reel].ToString()}");
            }
        }

        internal bool AreSlotsInEndPosition()
        {
            bool output = false;
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                if(objectsInGroup[i].objectInEndPosition)
                {
                    if (i == objectsInGroup.Length - 1)
                        output = true;
                }
            }
            return output;
        }
        ////Generate the strip in the direction and calculate based on slot size x y
        //internal override void GenerateLocalPositions(ConfigurationSettingsScriptableObject configurationSettings)
        //{
        //    localPositionsInStrip = new Vector3[]
        //}

        internal override List<BaseObjectManager> GetSlotsDecending()
        {
            List<BaseObjectManager> output = new List<BaseObjectManager>();
            //Debug.Log($"localPositionsInStrip.Length == {localPositionsInStrip.Length} - objectsInGroup.Length == {objectsInGroup.Length}");
            for (int position_to_check = 0; position_to_check < localPositionsInStrip.Length; position_to_check++)
            {
                for (int slot = 0; slot < objectsInGroup.Length; slot++)
                {
                    //Debug.Log($"objectsInGroup[{slot}].transform.localPosition {objectsInGroup[slot].transform.localPosition} == {localPositionsInStrip[position_to_check]} localPositionsInStrip[position_to_check] is {objectsInGroup[slot].transform.localPosition == localPositionsInStrip[position_to_check]}");
                    if (objectsInGroup[slot].transform.localPosition == localPositionsInStrip[position_to_check])
                        output.Add(objectsInGroup[slot]);
                }
            }
            return output;
        }

        private object PrintSlotObjectNames(StripObjectManager[] slotsList)
        {
            List<string> output = new List<string>();
            for (int slot = 0; slot < slotsList.Length; slot++)
            {
                output.Add(slotsList[slot].gameObject.name);
            }
            return String.Join("|", output);
        }

        internal NodeDisplaySymbolContainer ReturnNextSymbolInStrip()
        {
            int stripCounter = 0;
            NodeDisplaySymbolContainer output = stripInfo.spinInformation.spinIdleSymbolSequence[stripCounter];
            if (stripCounter + 1 >= stripInfo.spinInformation.spinIdleSymbolSequence.Length)
            {
                stripCounter = 0;
            }
            else
            {
                stripCounter += 1;
            }
            return output;
        }


        /// <summary>
        /// Generates a position for a slot in reel
        /// </summary>
        /// <param name="positionInStrip">Position in Reel slot will be</param>
        /// <returns>Slot Position Vector3</returns>
        internal Vector3 GetSlotPositionInStrip(int positionInStrip)
        {
            //TODO Base on Spin Direction
            //Debug.Log(String.Format("reelstrip_info.reel_number = {0} slot size = ({1},{2}) matrix padding.x = {3}", stripInfo.stripColumn, configurationObjectParent.configurationSettings.slotSize.x, configurationObjectParent.configurationSettings.slotSize.y, configurationObjectParent.configurationSettings.slotPadding.x));
            float x = 0;//reelstrip_info.reel_number * (matrix.configurationSettings.slotSize.x + matrix.configurationSettings.slotPadding.x);//Uncomment to set slot position at slot level
            float y = -(positionInStrip * (configurationObjectParent.configurationSettings.slotSize.y + configurationObjectParent.configurationSettings.slotPadding.y));
            //Debug.Log(string.Format("Local Position for slot {0} int reel {1} is ({2},{3},{4}) ",positionInStrip, transform.name,x.ToString(), y.ToString(),0));
            Vector3 return_position = new Vector3(x, y, 0);
            return return_position;
        }

        /// <summary>
        /// Sets the slots as referenced to the position in the reel
        /// </summary>
        internal void SetSlotPositionToStart()
        {
            //Debug.Log($"Setting positions to start {gameObject.name}");
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].transform.localPosition = localPositionsInStrip[i];
            }
        }

        internal void ClearObjectsInStrip()
        {
            for (int i = transform.childCount - 1; i >= 0; i--)
                Destroy(transform.GetChild(i).gameObject);
        }
        /// <summary>
        /// Sets all slot managers sub state machines to trigger and set bools
        /// </summary>
        internal void UpdateSlotManagersSubStateMachines()
        {
            for (int i = 0; i < objectsInGroup?.Length; i++)
            {
                objectsInGroup[i].SetSubStateMachineAnimators();
                objectsInGroup[i].SetAllSubSymbolsGameobjectActive();
            }
            configurationObjectParent._managers.endConfigurationManager.SetMatrixToReelConfiguration();
        }

        internal void InitializeLocalPositions()
        {
            Debug.Log($"{gameObject.name} Initializing local positions for displayZone.totalPositions {configurationGroupDisplayZones.totalPositions}");
            localPositionsInStrip = new Vector3[configurationGroupDisplayZones.totalPositions];
            for (int i = 0; i < localPositionsInStrip.Length; i++)
            {
                localPositionsInStrip[i] = GetSlotPositionInStrip(i);
            }
            Debug.Log($"localPositionsInStrip.Lengh = {localPositionsInStrip.Length}");
        }

        internal void SetLocalPositionsBySlotPositions()
        {
            if(localPositionsInStrip.Length < objectsInGroup.Length+1)
            {
                Debug.LogWarning($"localPositionsInStrip.Length {localPositionsInStrip.Length} < objectsInGroup.Length {objectsInGroup.Length + 1} = {localPositionsInStrip.Length < objectsInGroup.Length+1} creating new array to fill - You need to set the end position - you have been warned");
                localPositionsInStrip = new Vector3[objectsInGroup.Length + 1];
            }
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                localPositionsInStrip[slot] = objectsInGroup[slot].transform.localPosition;
            }
        }

        internal void SetPositionIndexOnPathForObjects()
        {
            for (int groupedObject = 0; groupedObject < objectsInGroup.Length; groupedObject++)
            {
                objectsInGroup[groupedObject].SetIndexOnPathfromCurrentPosition(ref localPositionsInStrip);
            }
        }
    }
}
