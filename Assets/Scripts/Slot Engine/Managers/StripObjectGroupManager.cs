//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Reel.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System;

namespace Slot_Engine.Matrix
{
#if UNITY_EDITOR
    using UnityEditor;
    public enum eEaseType
{
    constant,
    ease,
}


    [CanEditMultipleObjects]
    [CustomEditor(typeof(StripObjectGroupManager))]
    class ReelStripManagerEditor : BoomSportsEditor
    {
        StripObjectGroupManager my_target;

        public void OnEnable()
        {
            my_target = (StripObjectGroupManager)target;
        }

        public override void OnInspectorGUI()
        {
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("Controls");
            if(!Application.isPlaying)
            {
                if (GUILayout.Button("Set Slot Positions Initial"))
                {
                    my_target.SetSlotPositionToStart();
                }
                if (GUILayout.Button("Update Slot objects and positions local world reference"))
                {
                    my_target.UpdateStripPositions();
                }
                if (GUILayout.Button("Update sub state machines slot managers"))
                {
                    my_target.UpdateSlotManagersSubStateMachines();
                }
            }
            if (my_target.isSpinning)
            {
                if (GUILayout.Button("Spin Reel Test"))
                {
                    my_target.SpinGroupNow(true);
                }
                
            }
            else
            {
                if (GUILayout.Button("Enable Movement"))
                {
                    my_target.SetSlotsMovementEnabled(true);
                }
                if (GUILayout.Button("Disable Movement"))
                {
                    my_target.SetSlotsMovementEnabled(false);
                }
            }
            BoomEditorUtilities.DrawUILine(Color.white);
            base.OnInspectorGUI();
        }
    }

#endif

    public class StripObjectGroupManager : BaseObjectGroupManager
    {
        //the matrix associated with the reel_strip
        internal BaseConfigurationObject configurationObjectParent
        {
            get
            {
                if (base.configurationObjectParent == null)
                    base.configurationObjectParent = transform.GetComponentInParent<BaseConfigurationObject>();
                return base.configurationObjectParent;
            }
        }

        /// <summary>
        /// Holds the reel strip to cycle thru symbols for spin and end symbol configuration for reel
        /// </summary>
        [SerializeField]
        internal StripStruct stripInfo;
        /// <summary>
        /// Holds the reference for the slots position in path from entering to exiting reel area
        /// </summary>
        [SerializeField]
        internal Vector3[] localPositionsInStrip;
        /*
////For Spinning down the yCurve needs to be set for each
///// <summary>
///// start spin easing
///// </summary>
//public AnimationCurve[] start_spin_curve_xyz
//{
//    get
//    {
//        if (_start_spin_curve_xyz == null || _start_spin_curve_xyz.Length < 3)
//        {
//            _start_spin_curve_xyz = new AnimationCurve[3] {
//            AnimationCurve.Linear(0.0f,0,1,reel_spin_speed_direction.magnitude),
//            AnimationCurve.Linear(0.0f,0,1,reel_spin_speed_direction.magnitude),
//            AnimationCurve.Linear(0.0f,0,1,reel_spin_speed_direction.magnitude)
//            };
//        }
//        return _start_spin_curve_xyz;
//    }
//    set
//    {
//        _start_spin_curve_xyz = value;
//    }
//}
////Eases the speed over seconds
///// <summary>
///// Looping Path Time - slot 0 -> end slot - each key is a position in path. Speed - Speed -> pixels to move per Time.deltatime / seconds
///// </summary>
//public AnimationCurve[] looping_curves_xyz
//{
//    get
//    {
//        if (_looping_curves_xyz == null || _looping_curves_xyz.Length < 3)
//        {
//            _looping_curves_xyz = new AnimationCurve[3] {
//            AnimationCurve.Constant(0.0f,0.0f,reel_spin_speed_direction.magnitude), //todo calculate time to move over position in path v#
//            AnimationCurve.Constant(0.0f,0.0f,reel_spin_speed_direction.magnitude),
//            AnimationCurve.Constant(0.0f,0.0f,reel_spin_speed_direction.magnitude)
//            };
//        }
//        return _looping_curves_xyz;
//    }
//    set
//    {
//        _looping_curves_xyz = value;
//    }
//}

/// <summary>
/// end spin easing
/// </summary>
//public AnimationCurve[] end_spin_curve_xyz;
*/
        /// <summary>
        /// Draws debug GUI for User to see data in action
        /// </summary>
        public void OnDrawGizmos()
        {
            //Uncomment to see local positions reference for positions_in_path
            DrawDebugForPositionsOnPath();
        }    
        /// <summary>
        /// Used to draw positions in path
        /// </summary>
        private void DrawDebugForPositionsOnPath()
        {
            if(localPositionsInStrip != null)
            { 
            if (localPositionsInStrip.Length > 0)
                {
                    for (int i = 0; i < localPositionsInStrip.Length; i++)
                    {
                        if (i == 0)
                            Gizmos.DrawSphere(transform.TransformPoint(localPositionsInStrip[i]), 100f);//String.Format("Slot Start Position {0}", i));
                        else if (i == (localPositionsInStrip.Length - 1))
                            Gizmos.DrawSphere(transform.TransformPoint(localPositionsInStrip[i]), 100f);//String.Format("Slot End Position {0}", i));
                        else
                            Gizmos.DrawSphere(transform.TransformPoint(localPositionsInStrip[i]), 100f);//String.Format("Slot Display Position {0}", i));
                    }
                }
            }
        }
        internal void UpdateStripPositions()
        {
            Debug.LogWarning($"reelstrip_info.total_positions = {stripInfo.total_positions} reelstrip_info.total_slot_objects = {stripInfo.total_slot_objects}");
            UpdateLocalPositionsInPath(stripInfo.total_positions);
        }

        /// <summary>
        /// updates number of positions to store reference for based on reel length
        /// </summary>
        /// <param name="positions_to_generate_path_for">how many slots in reelstrip to save position reference</param>
        private void UpdateLocalPositionsInPath(int positions_to_generate_path_for)
        {
            //Setup the positions the slot will hit along path. Based on size and padding
            localPositionsInStrip = new Vector3[positions_to_generate_path_for]; //Spin into empty slots then move to top
            //get slots_in_reel: destroy slots if to many - add slots if to few
            for (int position_in_reel = 0; position_in_reel < localPositionsInStrip.Length; position_in_reel++)
            {
                localPositionsInStrip[position_in_reel] = GetSlotPositionInStrip(position_in_reel);
                //Debug.LogWarning($"positions_in_path_v3_local[position_in_reel] Generated for strip {gameObject.name} = {positions_in_path_v3_local[position_in_reel].ToString()}");
            }
        }

        internal bool AreSlotsInEndPosition()
        {
            bool output = false;
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                if(objectsInGroup[i].objectInEndPosition)
                {
                    if (i == objectsInGroup.Length - 1)
                        output = true;
                }
            }
            return output;
        }
        ////Generate the strip in the direction and calculate based on slot size x y
        //internal override void GenerateLocalPositions(ConfigurationSettingsScriptableObject configurationSettings)
        //{
        //    localPositionsInStrip = new Vector3[]
        //}

        internal override List<BaseObjectManager> GetSlotsDecending()
        {
            List<BaseObjectManager> output = new List<BaseObjectManager>();
            Debug.Log($"localPositionsInStrip.Length == {localPositionsInStrip.Length} - objectsInGroup.Length == {objectsInGroup.Length}");
            for (int position_to_check = 0; position_to_check < localPositionsInStrip.Length; position_to_check++)
            {
                for (int slot = 0; slot < objectsInGroup.Length; slot++)
                {
                    //Debug.Log($"objectsInGroup[slot].transform.localPosition {objectsInGroup[slot].transform.localPosition} == {positions_in_path_v3_local[position_to_check]} positions_in_path_v3_local[position_to_check] is {objectsInGroup[slot].transform.localPosition == positions_in_path_v3_local[position_to_check]}");
                    if(objectsInGroup[slot].transform.localPosition == localPositionsInStrip[position_to_check])
                        output.Add(objectsInGroup[slot]);
                }
            }
            return output;
        }

        private object PrintSlotObjectNames(StripObjectManager[] slotsList)
        {
            List<string> output = new List<string>();
            for (int slot = 0; slot < slotsList.Length; slot++)
            {
                output.Add(slotsList[slot].gameObject.name);
            }
            return String.Join("|", output);
        }

        internal NodeDisplaySymbol ReturnNextSymbolInStrip()
        {
            int stripCounter = 0;
            NodeDisplaySymbol output = stripInfo.spin_info.stripSpinSymbols[stripCounter];
            if (stripCounter + 1 >= stripInfo.spin_info.stripSpinSymbols.Length)
            {
                stripCounter = 0;
            }
            else
            {
                stripCounter += 1;
            }
            return output;
        }


        /// <summary>
        /// Generates a position for a slot in reel
        /// </summary>
        /// <param name="positionInStrip">Position in Reel slot will be</param>
        /// <returns>Slot Position Vector3</returns>
        internal Vector3 GetSlotPositionInStrip(int positionInStrip)
        {
            //TODO Base on Spin Direction
            //Debug.Log(String.Format("reelstrip_info.reel_number = {0} slot size = ({1},{2}) matrix padding.x = {3}", stripInfo.stripColumn, configurationObjectParent.configurationSettings.slotSize.x, configurationObjectParent.configurationSettings.slotSize.y, configurationObjectParent.configurationSettings.slotPadding.x));
            float x = 0;//reelstrip_info.reel_number * (matrix.configurationSettings.slotSize.x + matrix.configurationSettings.slotPadding.x);//Uncomment to set slot position at slot level
            float y = -(positionInStrip * (configurationObjectParent.configurationSettings.slotSize.y + configurationObjectParent.configurationSettings.slotPadding.y));
            //Debug.Log(string.Format("Local Position for slot {0} int reel {1} is ({2},{3},{4}) ",positionInStrip, transform.name,x.ToString(), y.ToString(),0));
            Vector3 return_position = new Vector3(x, y, 0);
            return return_position;
        }

        /// <summary>
        /// Sets the slots as referenced to the position in the reel
        /// </summary>
        internal void SetSlotPositionToStart()
        {
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].transform.localPosition = GetSlotPositionInStrip(i);
            }
        }

        internal void ClearObjectsInStrip()
        {
            for (int i = transform.childCount - 1; i >= 0; i--)
                Destroy(transform.GetChild(i).gameObject);
        }
        /// <summary>
        /// Sets all slot managers sub state machines to trigger and set bools
        /// </summary>
        internal void UpdateSlotManagersSubStateMachines()
        {
            for (int i = 0; i < objectsInGroup?.Length; i++)
            {
                objectsInGroup[i].SetSubStateMachineAnimators();
                objectsInGroup[i].SetAllSubSymbolsGameobjectActive();
            }
            configurationObjectParent._managers.endConfigurationManager.SetMatrixToReelConfiguration();
        }

        internal void InitializeLocalPositions(StripStruct tempStripStruct)
        {
            Debug.Log($"{gameObject.name} Initializing local positions for displayZone.totalPositions {tempStripStruct.stripDisplayZonesSetting.totalPositions}");
            localPositionsInStrip = new Vector3[tempStripStruct.stripDisplayZonesSetting.totalPositions];
            for (int i = 0; i < localPositionsInStrip.Length; i++)
            {
                localPositionsInStrip[i] = GetSlotPositionInStrip(i);
            }
            Debug.Log($"localPositionsInStrip.Lengh = {localPositionsInStrip.Length}");
        }
    }
}
