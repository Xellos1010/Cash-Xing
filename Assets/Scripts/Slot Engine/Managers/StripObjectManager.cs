//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Slot.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using static Slot_Engine.Matrix.EndConfigurationManager;
#if UNITY_EDITOR
using UnityEditor;
#endif
namespace Slot_Engine.Matrix
{
#if UNITY_EDITOR
    [CanEditMultipleObjects]
    [CustomEditor(typeof(StripObjectManager))]
    class SlotEditor : BoomSportsEditor
    {
        StripObjectManager myTarget;
        [Range(0,50)]
        float sliderTimerSpin;
        BasePathTransformSpinEvaluatorScriptableObject temp;
        public void OnEnable()
        {
            myTarget = (StripObjectManager)target;
        }

        public override void OnInspectorGUI()
        {
            //base.OnInspectorGUI();
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("Commands");
            if (GUILayout.Button("Calculate MoveObjectToSpinPosition()"))
            {
                Debug.Log($"MoveObjectToSpinPosition() output toPosition = {myTarget.MoveObjectToSpinPosition()}");
            }
            if (GUILayout.Button("Set Sub Animators State Machine"))
            {
                myTarget.SetSubStateMachineAnimators();
            }
            if (GUILayout.Button("Set Animators To Sync State Machine"))
            {
                myTarget.SetStateMachineAnimators();
            }
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("Editable Properties");
            EditorGUI.BeginChangeCheck();
            temp = myTarget.stripManager.stripInfo.GetSpinParameters();
            sliderTimerSpin = EditorGUILayout.Slider(sliderTimerSpin, 0, 2*(temp.GetTotalTime() * myTarget.stripManager.localPositionsInStrip.Length -1));
            if(EditorGUI.EndChangeCheck())
            {
                myTarget.MoveObjectToSpinPosition(sliderTimerSpin);
            }
            base.OnInspectorGUI();
        }
    }

#endif
    public class StripObjectManager : BaseObjectManager
    {
        /// <summary>
        /// Reference to the start position - always set on instantiate and spinEnd
        /// </summary>
        [SerializeField]
        internal int startPositionIndex;
        /// <summary>
        /// times object has reached end of path - set to 0 on spin start and instantiate
        /// </summary>
        [SerializeField]
        internal int timesReachedEndOfPath;

        /// <summary>
        /// StripGroupManager is a group of StripObjects
        /// </summary>
        public StripObjectGroupManager stripManager
        {
            get
            {
                return baseObjectGroupParent as StripObjectGroupManager;
            }
        }
        /// <summary>
        /// Used to pass a test constant spin timer update
        /// </summary>
        internal bool test = false;
        /// <summary>
        /// Starts a Spin
        /// </summary>
        public override void StartSpin( bool test = false)
        {
            ResetAllVars();
            timesReachedEndOfPath = 0;
            SetObjectMovementEnabledTo(true);
            this.test = test;
        }
        Vector3 SetPositionTo(Vector3 amount) //Needs to be positive to move forwards and negative to move backwards
        {
            //Debug.Log($"Setting transform.localPosition = {amount}");
            return amount; //new Vector3(transform.localPosition.x, transform.localPosition.y + amount_to_add, transform.localPosition.z);
        }
        Vector3 OffsetPositionBy(Vector3 amountToAdd) //Needs to be positive to move forwards and negative to move backwards
        {
            //Debug.Log($"Offsetting transform.localPosition {transform.localPosition} by {amountToAdd}");
            return transform.localPosition + amountToAdd; //new Vector3(transform.localPosition.x, transform.localPosition.y + amount_to_add, transform.localPosition.z);
        }
        internal override void Update()
        {
            if (spinMovementEnabled)
            {
                MoveObjectToSpinPosition();
            }
        }
        /// <summary>
        /// Moves an objects along SpinCycle (Spin Sequence/Path) and returns the calculated to position based on spinCurrentTimer;
        /// </summary>
        /// <returns></returns>
        internal Vector3 MoveObjectToSpinPosition()
        {
            if (Application.isPlaying)
            {
                //This is where you add functionality for reel reveal control
                spinCurrentTimer += Time.deltaTime;
            }
            return MoveObjectToSpinPosition(spinCurrentTimer);
        }
        /// <summary>
        /// Moves an objects along SpinCycle (Spin Sequence/Path) and returns the calculated to position based on spinCurrentTimer;
        /// </summary>
        /// <returns></returns>
        internal Vector3 MoveObjectToSpinPosition(float spinCurrentTimer)
        {
            toPosition = Vector3.zero;
            BasePathTransformSpinEvaluatorScriptableObject temp = stripManager.stripInfo.GetSpinParameters();
            StripObjectGroupManager temp2 = baseObjectGroupParent as StripObjectGroupManager;
            SpinPath pathToEvaluate = new SpinPath(temp2.localPositionsInStrip, startPositionIndex,temp2.configurationObjectParent.configurationSettings.slotSize, temp2.configurationObjectParent.configurationSettings.slotPadding);
            temp.EvaluateSpin(spinCurrentTimer, ref pathToEvaluate);
            toPosition = pathToEvaluate.toPositionEvaluated;
            //Debug.Log($"Setting Position to {toPosition.ToString()}");
            //Debug.Log($"Times reached end of path =  {pathToEvaluate.timesReachedEndOfPath} timesReachedEndOfPath supplied = {timesReachedEndOfPath}");
            if (timesReachedEndOfPath != pathToEvaluate.timesReachedEndOfPath)
            {
                timesReachedEndOfPath = pathToEvaluate.timesReachedEndOfPath;
                if (Application.isPlaying)
                    SetSymbolGraphics();
            }
            if (Application.isPlaying)
            {
                if(setToPresentationSymbolNextSpinCycle && presentationSymbolSetToEnd)
                {
                    if(Mathf.Abs(toPosition.sqrMagnitude) >= Mathf.Abs(stopSpinEndPosition.sqrMagnitude))
                    {
                        toPosition = stopSpinEndPosition;
                        objectInEndPosition = true;
                        spinMovementEnabled = false;
                    }
                }
                toPosition = SetPositionTo(toPosition);
                transform.localPosition = toPosition;
            }
            return toPosition;
        }

        private void SetSymbolGraphics()
        {
            if (setToPresentationSymbolNextSpinCycle)
            {
                //Set Graphics and end position
                //Debug.Log($"Setting {gameObject.name} end symbol in reel {baseObjectGroupParent.gameObject.name} stripManager.localPositionsInStrip.Length = {stripManager.localPositionsInStrip.Length} (stripManager.localPositionsInStrip.Length - 2 {stripManager.localPositionsInStrip.Length - 2}) - stripManager.endSymbolsSetFromConfiguration {stripManager.endSymbolsSetFromConfiguration}");
                presentationSymbolSetToEnd = true;
                stopSpinEndPosition = stripManager.localPositionsInStrip[(stripManager.localPositionsInStrip.Length - 2) - stripManager.endSymbolsSetFromConfiguration];

                if (stripManager.endSymbolsSetFromConfiguration < stripManager.ending_symbols.Length)
                {
                    SetDisplaySymbolTo(stripManager.ending_symbols[stripManager.ending_symbols.Length - 1 - stripManager.endSymbolsSetFromConfiguration]);
                    stopSpinEndPosition = stripManager.localPositionsInStrip[(stripManager.localPositionsInStrip.Length - 1) - stripManager.stripInfo.stripDisplayZonesSetting.paddingAfter - stripManager.endSymbolsSetFromConfiguration];
                    stripManager.endSymbolsSetFromConfiguration += 1;
                    //Set end position to paddig after = stripManager.endSymbolsSetFromConfiguration

                }
                else
                {
                    SetPresentationSymbolTo(-1); //TODO Define whether to set the top slot graphic
                }
                //Debug.Log("Slot " + transform.name + " symbol presentation = " + presentation_symbol + " end position = " + end_position);
            }
            else
            {
                bool symbol_set = false;
                NodeDisplaySymbol symbol = new NodeDisplaySymbol();
                if (stripManager.nextSymbolToAppear != -1)
                {
                    symbol = stripManager.configurationObjectParent.managers.endConfigurationManager.GetNodeDisplaySymbol(stripManager.nextSymbolToAppear).Result;
                    stripManager.nextSymbolToAppear = -1;
                }
                else
                {
                    if (stripManager.randomSetSymbolOnEndOfSequence)
                    {
                        //If Symbol Generated = opverlay - Generate Sub Symbol and attach 2 materials
                        if (stripManager.stripInfo.spin_info.stripSpinSymbols != null)
                        {
                            if (stripManager.stripInfo.spin_info.stripSpinSymbols.Length > 0)
                            {
                                symbol = stripManager.ReturnNextSymbolInStrip();
                                symbol_set = true;
                            }
                        }
                        if (!symbol_set)
                        {
                            //Determines an overlay symbol
                            symbol = stripManager.configurationObjectParent.managers.endConfigurationManager.GetRandomWeightedSymbol(StateManager.enCurrentMode).Result;
                        }
                    }
                }
                SetDisplaySymbolTo(symbol);
            }
        }

        internal Animator SetOverlayAnimatorToFeatureAndGet()
        {
            Animator output;
            //Compare to Symbols
            for (int i = 0; i < stripManager.configurationObjectParent.symbolDataScriptableObject.symbols.Length; i++)
            {
                if (stripManager.configurationObjectParent.isSymbolOverlay(i))
                {
                    output = stateMachine.animator_state_machines.sub_state_machines_values.sub_state_machines[0].sub_state_animators[i];
                    SetBoolTo(ref output, supportedAnimatorBools.FeatureTrigger, true);
                    return output;
                }
            }
            return null;
        }

    }
}