//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Slot.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using static Slot_Engine.Matrix.EndConfigurationManager;
#if UNITY_EDITOR
using UnityEditor;
#endif
namespace Slot_Engine.Matrix
{
#if UNITY_EDITOR
    [CanEditMultipleObjects]
    [CustomEditor(typeof(StripObjectManager))]
    class SlotEditor : BoomSportsEditor
    {
        StripObjectManager myTarget;
        [Range(0,50)]
        float sliderTimerSpin;
        BasePathTransformSpinEvaluatorScriptableObject temp;
        public void OnEnable()
        {
            myTarget = (StripObjectManager)target;
        }

        public override void OnInspectorGUI()
        {
            //base.OnInspectorGUI();
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("Commands");
            if (GUILayout.Button("Calculate MoveObjectToSpinPosition()"))
            {
                Debug.Log($"MoveObjectToSpinPosition() output toPosition = {myTarget.MoveObjectToSpinPosition()}");
            }
            if (GUILayout.Button("Set Sub Animators State Machine"))
            {
                myTarget.SetSubStateMachineAnimators();
            }
            if (GUILayout.Button("Set Animators To Sync State Machine"))
            {
                myTarget.SetStateMachineAnimators();
            }
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("Editable Properties");
            EditorGUI.BeginChangeCheck();
            temp = myTarget.stripManager.stripInfo.GetSpinParameters();
            sliderTimerSpin = EditorGUILayout.Slider(sliderTimerSpin, 0, 2*(temp.GetTotalTime() * myTarget.stripManager.localPositionsInStrip.Length -1));
            if(EditorGUI.EndChangeCheck())
            {
                myTarget.MoveObjectToSpinPosition(sliderTimerSpin);
            }
            base.OnInspectorGUI();
        }
    }

#endif
    public class StripObjectManager : BaseObjectManager
    {
        /// <summary>
        /// Reference to the start position - always set on instantiate and spinEnd
        /// </summary>
        [SerializeField]
        internal int startPositionIndex;
        /// <summary>
        /// times object has reached end of path - set to 0 on spin start and instantiate
        /// </summary>
        [SerializeField]
        internal int timesReachedEndOfPath;

        /// <summary>
        /// StripGroupManager is a group of StripObjects
        /// </summary>
        public StripObjectGroupManager stripManager
        {
            get
            {
                return baseObjectGroupParent as StripObjectGroupManager;
            }
        }
        /// <summary>
        /// Used to pass a test constant spin timer update
        /// </summary>
        internal bool test = false;
        internal bool endSpin;

        /// <summary>
        /// Starts a Spin
        /// </summary>
        public override void StartSpin( bool test = false)
        {
            ResetAllVars();
            timesReachedEndOfPath = 0;
            startPositionIndex = GetIndexFromLocalPositions();
            SetObjectMovementEnabledTo(true);
            endSpin = false;
            this.test = test;
        }

        private int GetIndexFromLocalPositions()
        {
            for (int i = 0; i < stripManager.localPositionsInStrip.Length; i++)
            {
                if(transform.localPosition.sqrMagnitude == stripManager.localPositionsInStrip[i].sqrMagnitude)
                {
                    return i;
                }
            }
            Debug.LogWarning("Position not found in local position manager. returning -1");
            return -1;
        }

        Vector3 SetPositionTo(Vector3 toPosition) //Needs to be positive to move forwards and negative to move backwards
        {
            //Debug.Log($"Setting transform.localPosition = {amount}");
            transform.localPosition = toPosition;
            return toPosition; //new Vector3(transform.localPosition.x, transform.localPosition.y + amount_to_add, transform.localPosition.z);
        }
        Vector3 OffsetPositionBy(Vector3 amountToAdd) //Needs to be positive to move forwards and negative to move backwards
        {
            //Debug.Log($"Offsetting transform.localPosition {transform.localPosition} by {amountToAdd}");
            return transform.localPosition + amountToAdd; //new Vector3(transform.localPosition.x, transform.localPosition.y + amount_to_add, transform.localPosition.z);
        }
        internal override void Update()
        {
            if (spinMovementEnabled)
            {
                MoveObjectToSpinPosition();
            }
        }
        /// <summary>
        /// Moves an objects along SpinCycle (Spin Sequence/Path) and returns the calculated to position based on spinCurrentTimer;
        /// </summary>
        /// <returns></returns>
        internal Vector3 MoveObjectToSpinPosition()
        {
            if (Application.isPlaying)
            {
                //This is where you add functionality for reel reveal control
                spinCurrentTimer += Time.deltaTime;
            }
            return MoveObjectToSpinPosition(spinCurrentTimer);
        }
        /// <summary>
        /// Moves an objects along SpinCycle (Spin Sequence/Path) and returns the calculated to position based on spinCurrentTimer;
        /// </summary>
        /// <returns></returns>
        internal Vector3 MoveObjectToSpinPosition(float spinCurrentTimer)
        {
            Debug.Log($"{gameObject.name} is MoveObjectToSpinPosition( spinCurrentTimer ={spinCurrentTimer})");
            toPosition = Vector3.zero;
            BasePathTransformSpinEvaluatorScriptableObject temp = stripManager.stripInfo.GetSpinParameters();
            //TODO Test Generic Evaluate Spin - TODO Add abtract function to return positions in object group
            StripObjectGroupManager temp2 = baseObjectGroupParent as StripObjectGroupManager;
            //Sets up our spin path - calculates sqr magnitudes between each point in path - Compare absolute sqr magnitude of object local position and last position in path to move to start of path
            SpinPath pathToEvaluate = new SpinPath(temp2.localPositionsInStrip, startPositionIndex,temp2.configurationObjectParent.configurationSettings.slotSize, temp2.configurationObjectParent.configurationSettings.slotPadding);
            
            //Stepper Logic - The evaluating object checks if you have a set amount of steps or rotations to make in spin then to return constant value once ceiling has been reached 
            temp.EvaluateSpin(spinCurrentTimer, ref pathToEvaluate);
            toPosition = pathToEvaluate.toPositionEvaluated;
            if (timesReachedEndOfPath != pathToEvaluate.timesReachedEndOfPath)
            {
                timesReachedEndOfPath = pathToEvaluate.timesReachedEndOfPath;
                if (Application.isPlaying)
                    SetSymbolGraphics();
            }
            if (Application.isPlaying)
            {
                if (setToPresentationSymbolNextSpinCycle && presentationSymbolSetToEnd)
                {
                    if (Mathf.Abs(toPosition.sqrMagnitude) >= Mathf.Abs(stopSpinEndPosition.sqrMagnitude))
                    {
                        toPosition = stopSpinEndPosition;
                        objectInEndPosition = true;
                        spinMovementEnabled = false;
                    }
                }
                else if (endSpin == true)
                { 
                    if (!temp.isTimeInPauseState(spinCurrentTimer))
                    {
                        if (toPosition == stripManager.localPositionsInStrip[stripManager.localPositionsInStrip.Length - 1])
                            toPosition = stripManager.localPositionsInStrip[0];
                        stopSpinEndPosition = toPosition;
                        objectInEndPosition = true;
                        spinMovementEnabled = false;
                    }
                }
                toPosition = SetPositionTo(toPosition);
            }
            return toPosition;
        }

        private void SetSymbolGraphics()
        {

            bool symbol_set = false;
            NodeDisplaySymbol symbol = new NodeDisplaySymbol();
            //First we check if we have symbols in a list to present next - then we go based on set presentation symbol - This will break under certain conditions but works for now.
            if (stripManager.nextSymbolToAppear.Count > 0)
            {
                symbol = stripManager.configurationObjectParent.managers.endConfigurationManager.GetNodeDisplaySymbol(stripManager.nextSymbolToAppear.Pop<int>()).Result;
            }
            else
            {
                if (setToPresentationSymbolNextSpinCycle)
                {
                    //Set Graphics and end position
                    //Debug.Log($"Setting {gameObject.name} end symbol in reel {baseObjectGroupParent.gameObject.name} stripManager.localPositionsInStrip.Length = {stripManager.localPositionsInStrip.Length} (stripManager.localPositionsInStrip.Length - 2 {stripManager.localPositionsInStrip.Length - 2}) - stripManager.endSymbolsSetFromConfiguration {stripManager.endSymbolsSetFromConfiguration}");
                    presentationSymbolSetToEnd = true;
                    stopSpinEndPosition = stripManager.localPositionsInStrip[(stripManager.localPositionsInStrip.Length - 2) - stripManager.endSymbolsSetFromConfiguration];

                    if (stripManager.endSymbolsSetFromConfiguration < stripManager.ending_symbols.Length)
                    {
                        SetDisplaySymbolTo(stripManager.ending_symbols[stripManager.ending_symbols.Length - 1 - stripManager.endSymbolsSetFromConfiguration]);
                        stopSpinEndPosition = stripManager.localPositionsInStrip[(stripManager.localPositionsInStrip.Length - 1) - stripManager.stripInfo.stripDisplayZonesSetting.paddingAfter - stripManager.endSymbolsSetFromConfiguration];
                        stripManager.endSymbolsSetFromConfiguration += 1;
                        symbol_set = true;
                        //Set end position to paddig after = stripManager.endSymbolsSetFromConfiguration

                    }
                    else
                    {
                        SetPresentationSymbolTo(-1); //TODO Define whether to set the top slot graphic
                        stopSpinEndPosition = stripManager.localPositionsInStrip[(stripManager.localPositionsInStrip.Length - 1) - stripManager.stripInfo.stripDisplayZonesSetting.paddingAfter - stripManager.endSymbolsSetFromConfiguration];
                        stripManager.endSymbolsSetFromConfiguration += 1;
                        symbol_set = true;
                    }
                    //Debug.Log("Slot " + transform.name + " symbol presentation = " + presentation_symbol + " end position = " + end_position);
                }

                else
                {
                    if (stripManager.randomSetSymbolOnEndOfSequence)
                    {
                        //If Symbol Generated = opverlay - Generate Sub Symbol and attach 2 materials
                        if (stripManager.stripInfo.spin_info.stripSpinSymbols != null)
                        {
                            if (stripManager.stripInfo.spin_info.stripSpinSymbols.Length > 0)
                            {
                                symbol = stripManager.ReturnNextSymbolInStrip();
                                symbol_set = true;
                            }
                        }
                    }
                }

                //In-case nothing was set set to random 
                if (!symbol_set)
                {
                    Debug.LogWarning("Symbol was not set - auto setting random");
                    //Determines an overlay symbol
                    symbol = stripManager.configurationObjectParent.managers.endConfigurationManager.GetRandomWeightedSymbol(StateManager.enCurrentMode).Result;
                }
                SetDisplaySymbolTo(symbol);
            }
            
        }

        internal Animator SetOverlayAnimatorToFeatureAndGet()
        {
            Animator output;
            //Compare to Symbols
            for (int i = 0; i < stripManager.configurationObjectParent.symbolDataScriptableObject.symbols.Length; i++)
            {
                if (stripManager.configurationObjectParent.isSymbolOverlay(i))
                {
                    output = stateMachine.animator_state_machines.sub_state_machines_values.sub_state_machines[0].sub_state_animators[i];
                    SetBoolTo(ref output, supportedAnimatorBools.FeatureTrigger, true);
                    return output;
                }
            }
            return null;
        }
        /// <summary>
        /// Used to set the slot to go to end position
        /// </summary>
        internal override void SetToStopSpin()
        {
            if (stripManager.stripInfo.stripDisplayZonesSetting.spinParameters.GetType() == typeof(StripSpinDirectionalStepperEvaluatorScriptableObject))
            {
                Debug.Log($"{stripManager.gameObject.name} {gameObject.name} spin parameters = {stripManager.stripInfo.stripDisplayZonesSetting.spinParameters.GetType()}");
                endSpin = true;
            }
            else
            {
                setToPresentationSymbolNextSpinCycle = true;
                objectInEndPosition = false;
                presentationSymbolSetToEnd = false;
            }
        }
    }
}