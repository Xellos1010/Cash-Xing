//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Reel.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
using System.Threading.Tasks;
using System;
using System.Collections.Generic;
using BoomSports.Prototype.ScriptableObjects;

namespace BoomSports.Prototype.Managers
{
    /// <summary>
    /// Base class 
    /// </summary>
    public class BaseObjectGroupManager : MonoBehaviour
    {
        /// <summary>
        /// Used to send an event that an object group has started/stopped spin and which one
        /// </summary>
        /// <param name="objectNumber"></param>
        public delegate void ObjectGroupEventEvent(int objectNumber);
        public event ObjectGroupEventEvent objectGroupStartSpin;
        public event ObjectGroupEventEvent objectGroupEndSpin;
        /// <summary>
        /// current spinState of Group
        /// </summary>
        [SerializeField]
        internal SpinStates currentSpinState;
        /// <summary>
        /// Index of group manager in parent array
        /// </summary>
        [SerializeField]
        public int indexInGroupManager;
        /// <summary>
        /// Display Zones for group
        /// </summary>
        [SerializeField]
        public ConfigurationDisplayZonesStruct configurationGroupDisplayZones;
        [SerializeField]
        internal BaseConfigurationObjectManager configurationObjectParent;
        /// <summary>
        /// Object managers in Group
        /// </summary>
        [SerializeField] //If base inspector enabled can check references
        internal BaseObjectManager[] objectsInGroup;
        /// <summary>
        /// used to track the end display sequence. In decending display order - Cash Crossing: stepper strip will replace 1 symbol on reel per spin - directional constant will replace all symbols on strip. Updated on SpinStart()
        /// </summary>
        [SerializeField]
        internal NodeDisplaySymbolContainer[] symbolsDisplaySequence;
        /// <summary>
        /// When an object is moves from last position to first the symbol is changed.
        /// </summary>
        public List<int> debugNextSymbolsToLoad;
        /// <summary>
        /// Enables you to change the symbol graphic when slot exits the viewable area of a configuration to a predefined strip or random draw weighte distribution symbol
        /// </summary>
        [SerializeField]
        public bool randomSetSymbolOnEndOfSequence = true;
        /// <summary>
        /// Temporarily used to activate trailing multiplier
        /// </summary>
        public bool trailingActive = false;
        /// <summary>
        /// UI Indicator to ensure operation for setting symbols to end configuration has performed
        /// </summary>
        [SerializeField]
        internal int endSymbolsSetFromConfiguration = 0;
        [SerializeField]
        internal GroupInformationStruct groupInfo;
        /// <summary>
        /// Initial Position offset when object in group is set to start path - Used for directional
        /// </summary>
        [SerializeField]
        internal Vector3 initialPositionSetAtTopOffset;
        internal bool areObjectsInEndPosition
        {
            get
            {
                bool output = true;
                for (int i = 0; i < objectsInGroup.Length; i++)
                {
                    if (!objectsInGroup[i].objectInEndPosition)
                    {
                        break;
                    }
                    if (i == objectsInGroup.Length - 1)
                    {
                        output = false;
                    }
                }
                return output;
            }
        }

        /// <summary>
        /// Symbols that activate slot features - Trailing multiplier in cash crossing lights up the plus sign on enter
        /// </summary>
        public ObjectGroupConditionalActivatorsContainer objectGroupConditionalActivatorsContainer;
        /// <summary>
        /// Set this to spin at index until 0 then spin at start - will not work for multiple index at path
        /// </summary>
        public int spinAtIndexFor = 0;
        /// <summary>
        /// Controls what index in path to start spinning at max index rows in column - padding after reel
        /// </summary>
        public int spinAtIndexInPath = 0;
        /// <summary>
        /// Used to track the slot off matrix to spin into position
        /// </summary>
        public BaseObjectManager paddingSlot;

        ///// <summary>
        ///// Structure for tracking slots in group that have symbols that activate features
        ///// </summary>
        //[Serializable]
        //public struct ActivatorTracker
        //{
        //    /// <summary>
        //    /// Symbol being tracked
        //    /// </summary>
        //    [SerializeField]
        //    public int symbol;
        //    /// <summary>
        //    /// Tracks which index's on strip the symbol is currently on
        //    /// </summary>
        //    [SerializeField]
        //    public int[] indexsSymbolResidesInStrip;
        //}

        ///// <summary>
        ///// Tracks which index in object group symbol activator is in. if there are multiple will track by symbol
        ///// </summary>
        //internal List<ActivatorTracker> activatorObjectGroupSymbolIndex
        //{
        //    get
        //    {
        //        if (_activatorObjectGroupSymbolIndex == null)
        //            _activatorObjectGroupSymbolIndex = new List<ActivatorTracker>();
        //        return _activatorObjectGroupSymbolIndex;
        //    }
        //}
        ///// <summary>
        ///// Tracks which index in object group symbol activator is in. if there are multiple will track by symbol
        ///// </summary>
        //[SerializeField]
        //internal List<ActivatorTracker> _activatorObjectGroupSymbolIndex;
        ///// <summary>
        ///// Used to recieve events from the strip with symbol that activated
        ///// </summary>
        //public void OnSlotActivatorEnterTriggered(int symbolEnter)
        //{
        //    //Find all index of slots triggering and trigger connected object
        //}
        /// <summary>
        /// Used to recieve events from the strip with symbol that activated
        /// </summary>
        //public void OnSlotActivatorExitTriggered(int symbolExit)
        //{
        //    //Find the index of slot triggered and trigger feature bridge animator in slot
        //}

        internal void ConditionalCheckNextSlotInPathFrom(BaseObjectManager baseObjectManager)
        {
            //get current position in path and next position in path
            //baseObjectManager.
            //Get position of object ini strip and check if next position in path Evaluates to true
            //Conditional check for Multiplier - Always - OnSlotEnter - Symbol Name Contains SA02
        }

        /// <summary>
        /// is the reel in a spin state
        /// </summary>
        internal bool isSpinning
        {
            get
            {
                bool output = true;
                if (objectsInGroup != null)
                {
                    for (int slot = 0; slot <= objectsInGroup.Length; slot++)
                    {
                        if (slot < objectsInGroup.Length)
                        {
                            if (objectsInGroup[slot] != null)
                            {
                                if (slot == objectsInGroup.Length)
                                {
                                    output = false;
                                    break;
                                }
                                if (objectsInGroup[slot].spinMovementEnabled)
                                {
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    return false;
                }
                return output;
            }
        }
        public bool registerStartSpinWithObjectsEvent = true;
        public bool registerOnNextSymbolChangeWithObjectsEvent = false;
        public void OnEnable()
        {
            //RegisterWithObjectsInGroupEvents();
        }

        private void RegisterWithObjectsInGroupEvents()
        {
            if (registerStartSpinWithObjectsEvent || registerOnNextSymbolChangeWithObjectsEvent)
            {
                for (int groupedObject = 0; groupedObject < objectsInGroup.Length; groupedObject++)
                {
                    if(registerStartSpinWithObjectsEvent)
                    {
                        objectsInGroup[groupedObject].startSpinCheckNextPointInPath += BaseObjectGroupManager_startSpinCheckNextPointInPath;
                    }
                }
            }
        }

        /// <summary>
        /// Right now used for stepper reel specifically to check next symbol in path
        /// </summary>
        /// <param name="objectInPath"></param>
        private void CheckSymbolInSequenceForConditionalEvents(int symbolID, int indexInEndSequence, ConfigurationDisplayZonesStruct objectGroupManagerDisplayZones)
        {
            BaseSlotActivatorEventConditional[] conditionalsToCheck = objectGroupConditionalActivatorsContainer.GetAllConditionalChecks();
            SymbolObjectGroupEvaluatorContainer symbolEvaluationContainer = new SymbolObjectGroupEvaluatorContainer(symbolID, indexInEndSequence, objectGroupManagerDisplayZones);
            //Iterate thru evaluators and evaluate for a true condition
            for (int i = 0; i < conditionalsToCheck.Length; i++)
            {
                if (conditionalsToCheck[i].EvaluateCondition(symbolEvaluationContainer))
                {
                    //Evaluate Condition handles invoking events - may change in future
                }
            }
        }

        /// <summary>
        /// Right now used for stepper reel specifically to check next symbol in path
        /// </summary>
        /// <param name="objectInPath"></param>
        private void BaseObjectGroupManager_startSpinCheckNextPointInPath(BaseObjectManager objectInPath)
        {
            BaseSlotActivatorEventConditional[] conditionalsToCheck = objectGroupConditionalActivatorsContainer.GetAllConditionalChecks();
            //Iterate thru evaluators and evaluate for a true condition
            for (int i = 0; i < conditionalsToCheck.Length; i++)
            {
                if(conditionalsToCheck[i].EvaluateCondition(objectInPath))
                {
                    //Cash-Crossing Specific - Send signal to bridge manager to set bonus pulse to idle
                    Debug.Log($"{gameObject.name} {objectInPath.gameObject.name} Activated Slot Condition -TODO label add slot conditional active");
                }
            }
        }

        public void OnDisable()
        {
            //DeregisterWithObjectsInGroupEvents();
        }

        private void DeregisterWithObjectsInGroupEvents()
        {
            if (registerStartSpinWithObjectsEvent || registerOnNextSymbolChangeWithObjectsEvent)
            {
                for (int groupedObject = 0; groupedObject < objectsInGroup.Length; groupedObject++)
                {
                    if (registerStartSpinWithObjectsEvent)
                    {
                        objectsInGroup[groupedObject].startSpinCheckNextPointInPath -= BaseObjectGroupManager_startSpinCheckNextPointInPath;
                    }
                }
            }
        }
        /// <summary>
        /// Sets a spin index at point in path based on feature data passed - todo refactor for generix access
        /// </summary>
        /// <param name="triggerFeatureEvaluationScriptableObject"></param>
        /// <param name="indexToSpinAt"></param>
        internal void SetSpinAtIndexTo(int indexToSpinAt)
        {
            //Cash Crossing specific
            spinAtIndexInPath = indexToSpinAt;
            if (spinAtIndexInPath > 0)
            {
                spinAtIndexFor = 3;//TODO refactor Hardcoding 
                trailingActive = true;
            }
            else
            {
                spinAtIndexFor = -1;//TODO refactor Hardcoding 
                trailingActive = false;
            }
        }
        /// <summary>
        /// Sets a spin index at point in path based on feature data passed - todo refactor for generix access
        /// </summary>
        /// <param name="triggerFeatureEvaluationScriptableObject"></param>
        /// <param name="indexToSpinAt"></param>
        internal void SetSpinAtIndexWithParamaters(TriggerFeatureEvaluationScriptableObject triggerFeatureEvaluationScriptableObject, int indexToSpinAt)
        {
            //Cash Crossing specific
            spinAtIndexInPath = indexToSpinAt;
            spinAtIndexFor = 3;//TODO refactor Hardcoding 
            trailingActive = true;
            if(triggerFeatureEvaluationScriptableObject.featureToTrigger == Features.multiplier)
            {
                DebugLoadSymbols(9,3);
            }
        }

        /// <summary>
        /// Sets debug symbols to load.
        /// </summary>
        /// <param name="symbolToLoad"></param>
        /// <param name="howManyToLoad"></param>
        private void DebugLoadSymbols(int symbolToLoad, int howManyToLoad)
        {
            for (int i = 0; i < symbolToLoad; i++)
            {
                debugNextSymbolsToLoad.Add(symbolToLoad);
            }
        }

        /// <summary>
        /// Spin the Reels
        /// </summary>
        /// <returns>async task to track</returns>
        /// OOP(Order of Operations Cash Crossing) 
        /// On any spin = Initialize Padding Slot, Set Symbol Sequence based on symbols replaced at index on path. Return spin from start at anytime after spin completes
        /// - If spin at index != 0 then set padding slot new position and symbol from first debug then set to random symbol. 
        /// --Trailing will only activate on spin > 0 but testing can be 0.
        /// --After trailing feature active initialize padding slot to index on path and pull symbol from debug list to load. 
        /// --After x spins turn off feature - multipliers set 2x-10x for X symbols - wilds trail X symbols.
        /// ---*Math will make it impossible for 3 trailing features to activate on 1 reel
        /// --Activate trailing multipliers on left reel and trailing wild on right reel
        /// Highlight center symbol on any symbol win. - Animator trigger FeatureOn and FeatureOff
        /// On Spin Start after initialize padding slot get symbol sequence
        /// ---OOP Reel Split - Set index on reel path to start spin - initiale padding slot to index on path - calculate number of symbols to replace per spin - padding slot becomes first symbol at index to be inserted - all symbols until padding before are inserted at index - all padding symbols inserted at beggining of sequence so evaluation manager can process.
        public virtual Task StartSpin()
        {
            //Invoke spin event
            objectGroupStartSpin?.Invoke(indexInGroupManager);
            //Initialize if spin at index expired based on debug symbols set on strip - temporary hack
            if(debugNextSymbolsToLoad.Count < 1)
            {
                //Will auto set properties to be affected
                SetSpinAtIndexTo(0);
            }
            //Initialize Padding slot start position - Ensure graphic of padding slot set to next graphic in sequence - will return a list of slots 
            InitializePaddingSlotPositionAndSymbol();
            //Set new ending symbols based on reel. if padding slot was moved then first symbol is a non-evaluated symbol anyway.
            InitializeEndDisplaySequenceToSet();
            PrintSymbolSequence(ref symbolsDisplaySequence, "symbolsDisplaySequence after InitializeEndDisplaySequenceToSet() ");
            //Ensure display sequence is set to symbols in list since padding slot can move
            List<BaseObjectManager> baseObjectsToSpin =  GetSlotsDecending();
            string debugMessage = "";
            for (int i = 0; i < baseObjectsToSpin.Count; i++)
            {
                debugMessage += $"[{i}] = |{baseObjectsToSpin[i].gameObject.name} currentDisplaySymbolID = {baseObjectsToSpin[i].currentPresentingSymbolID}|";
            }
            Debug.Log($"Slots Decending == \n {debugMessage}");
            //Used to ensure the proper order of operations
            //Display Symbol Sequence is in end sequence - need to pull from bottom up symbols to replace as reach top

            //SetObjectsDisplaySymbolsToSequence(baseObjectsToSpin.ToArray());
            //Switching to ObjectManager of spin object to invoke check of display symbol and row in strip.
            //Check each symbols next position - any symbol activating a condition send event to recieving object
            //Cash Crossing when a bonus symbol enters a slot it sends idle trigger to associated bridge animator
            InitializeConditionalEvents();
            CheckForConditionalEventsFromEndDisplaySequence(symbolsDisplaySequence);

            SetSpinStateTo(SpinStates.spin_start);

            //Need to account for index in path
            //if symbols to replace on reel < objectsInGroup.Length then set reel to end spin 
            //for (int i = 0; i < objectsInGroup.Length; i++)
            for (int i = spinAtIndexInPath; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].StartSpin();
                if (GetSymbolsToBeReplacedPerSpin() < GetTotalDisplaySlots())
                {
                    //Debug.Log($"{gameObject.name} is setting spin to stop on start spin.");
                    //Stepper reels need to set symbol to latest in sequence
                    objectsInGroup[i].SetToStopSpin();
                }
            }
            //If event on symbol stop then evaluate if event conidtions were reached - ie SpinDirectionalStepper a bonus trigger will land on the strip and a + will glow symbo
            //TODO refactor check for interupt state
            SetSpinStateTo(SpinStates.spin_idle);
            return Task.CompletedTask;
        }

        private void PrintSymbolSequence(ref NodeDisplaySymbolContainer[] symbolsDisplaySequence,string message)
        {
            string symbolSequenceDebugMessage = "";
            for (int i = 0; i < symbolsDisplaySequence.Length; i++)
            {
                symbolSequenceDebugMessage += $"|{symbolsDisplaySequence[i].primarySymbol}";
            }
            Debug.Log($"{message} = {symbolSequenceDebugMessage}");
        }

        /// <summary>
        /// Initialize where to place the padding slot and the symbol on the slot. Only executes on start spin - will not work when objects are moving
        /// </summary>
        internal void InitializePaddingSlotPositionAndSymbol()
        {
            //If the start of the spin has to spin at index and padding slot is != to localPositionsInStrip[spinAtIndexInPath] then put it at position and change graphic to next graphic in debug sequence
            //If a slot spun and index on path was set to 0 - the display symbol sequence list will pop then be overwritten by the debug symbol losing one symbol in sequence.
            //If start 
            StripObjectGroupManager strip = (StripObjectGroupManager)this;
            if (paddingSlot.transform.localPosition != strip.localPositionsInStrip[spinAtIndexInPath])
            {
                Debug.Log($"Initializing padding slot position for start spin");
                paddingSlot.SetPositionToIndexInPath(strip.localPositionsInStrip[spinAtIndexInPath], spinAtIndexInPath);
                //Cash Crossing Specific Only - TODO refactor
                int symbol = -1;

                if (debugNextSymbolsToLoad.Count > 0)
                    symbol = debugNextSymbolsToLoad.Pop<int>();
                else
                {
                    Debug.Log($"No debug symbols to set - setting padding slot to random SymbolID");
                    symbol = UnityEngine.Random.Range(0, 3); // TODO get symbols range from configuration object
                }
                Debug.Log($"Setting padding slot SymbolID to {symbol}");
                paddingSlot.SetDisplaySymbolTo(new NodeDisplaySymbolContainer(symbol));
            }
            //if (spinAtIndexInPath > 0)
            //{
            //    List<BaseObjectManager> groupManagers = GetSlotsDecending();
            //    TODO refactor and abstract
            //    StripObjectGroupManager strip = (StripObjectGroupManager)this;
            //    Check if first slot is in padding position and adjust
            //    if(groupManagers[0].transform.localPosition == strip.localPositionsInStrip[0])
            //    {
            //        groupManagers[0].SetPositionToIndexInPath(strip.localPositionsInStrip[spinAtIndexInPath], spinAtIndexInPath);
            //    }
            //    else //need to account for when the strip sets the initial slot to after padding slot
            //    {
            //        Find position in path where x/y are same and take one with less z depth and move to position
            //        ReturnPaddingSlot();
            //    }
            //}
            //else
            //{
            //    Check there is a padding slot at initial position
            //}
        }

        private int GetTotalDisplaySlots()
        {
            return configurationGroupDisplayZones.displayZonesPositionsTotal;
        }

        internal void InitializeConditionalEvents()
        {
            BaseSlotActivatorEventConditional[] conditionalsToCheck = objectGroupConditionalActivatorsContainer.GetAllConditionalChecks();
            //Iterate thru evaluators and evaluate for a true condition
            for (int i = 0; i < conditionalsToCheck.Length; i++)
            {
                conditionalsToCheck[i].Initialize();
            }
        }

        internal void CheckForConditionalEventsFromEndDisplaySequence(NodeDisplaySymbolContainer[] symbolsDisplaySymbolsSequence)
        {
            //Cash Crossing Specific
            //Need to include logic for padding and active vs inactive display zones so we send the right index to the bridge manager
            for (int symbolIndex = configurationGroupDisplayZones.paddingBefore; symbolIndex < symbolsDisplaySymbolsSequence.Length; symbolIndex++)
            {
                //TODO: Future refactor required to support active vs inactive display zone and proper index association
                CheckSymbolInSequenceForConditionalEvents(symbolsDisplaySymbolsSequence[symbolIndex].primarySymbol, symbolIndex,configurationGroupDisplayZones);
            }
        }

        /// <summary>
        /// Gets the number of symbols in a group that will be replaced on a spin
        /// </summary>
        /// <returns></returns>
        internal int GetSymbolsToBeReplacedPerSpin()
        {
            //Access Spin Parameters and get number of symbols to replace per spin
            return configurationGroupDisplayZones.spinParameters.GetSymbolsReplacedPerSpin(objectsInGroup.Length,configurationGroupDisplayZones,spinAtIndexInPath);
            //Ex: stepper replaces x symbols x=steps per spin allowed. Directional Constant is full strip clear
        }

        internal string PrintCurrentDisplaySymbols()
        {
            string output = "";
            List<BaseObjectManager> lastInFirstOut = GetSlotsDecending();
            for (int i = 0; i < lastInFirstOut.Count; i++)
            {
                output += $"|{lastInFirstOut[i].currentPresentingSymbolID}";
            }
            return output;
        }

        internal NodeDisplaySymbolContainer[] GetCurrentDisplaySymbolsFromDecending()
        {
            //If padding slot is initialized to index at path then need to search and insert padding slot into list - move last symbol out to first position in - padding slot will spin into place
            List<BaseObjectManager> lastInFirstOut = GetSlotsDecending();
            Debug.Log($"{gameObject.name} GetSlotsDecending() raw count = {GetSlotsDecending().Count}");
            //TODO Refactor and abstract - hack for cash crossing
            //if (spinAtIndexInPath > 0) //
            //{
            //    padding slot is initialized for trailing - Cash Crossing -
            //    Insert padding slot into index at path
            //    Set last element to first new element - designed specifically for Cash Crossing single reel stepper use -case -needs more testing for multiple steps
            //    **Last elements removed in calling script - return raw slot descending order
            //    lastInFirstOut.Insert(spinAtIndexInPath, paddingSlot);
            //    lastInFirstOut.Insert(0, lastInFirstOut[lastInFirstOut.Count - 1]);
            //    lastInFirstOut.RemoveAt(lastInFirstOut.Count - 1);
            //}

            NodeDisplaySymbolContainer[] output = new NodeDisplaySymbolContainer[lastInFirstOut.Count];
            for (int i = 0; i < lastInFirstOut.Count; i++)
            {
                output[i] = new NodeDisplaySymbolContainer(lastInFirstOut[i].currentPresentingSymbolID);
            }
            if(output.Length < objectsInGroup.Length)
            {
                Debug.LogWarning($"Getting slots descending did not return all objects for {gameObject.name} logic is based on current slot positions matching positions in path. Sync up slot positions to set positions in path or visa versa using the Configuration Object Manager Editor Options");
            }
            return output;
        }

        internal int GetIndexInGroup()
        {
            return configurationObjectParent.GetIndexOfGroupManager(this);
        }

        /// <summary>
        /// Spin the Reels
        /// </summary>
        /// <returns>async task to track</returns>
        public void SpinGroupNowTestNoAnimator(bool test = false)
        {
            StartSpin();
            //    InitializeEndingDisplayForNewSpin();

            //    //When reel is generated it's vector3[] path is generated for reference from slots
            //    SetSpinStateTo(SpinStates.spin_start);
            //    //TODO hooks for reel state machine
            //    for (int i = 0; i < objectsInGroup.Length; i++)
            //    {
            //        //Last slot needs to ease in and out to the "next position" but 
            //        objectsInGroup[i].StartSpin(test); // Tween to the same position then evaluate
            //    }
            //    //Task.Delay(time_to_enter_loop);
            //    //TODO Implement Ease In for Starting spin
            //    //TODO refactor check for interupt state
            //    SetSpinStateTo(SpinStates.spin_idle);
        }
        /// <summary>
        /// Sets the Spin State to state
        /// </summary>
        /// <param name="state">SpinStates state to set reel to</param>
        private void SetSpinStateTo(SpinStates state)
        {
            currentSpinState = state;
        }
        /// <summary>
        /// Initializes Ending Display Symbols for Strip.
        /// </summary>
        internal void InitializeEndDisplaySequenceToSet()
        {
            SetDisplaySymbolsForNextSpin();
        }
        /// <summary>
        /// Gets the display slots for the next spin - Stepper is partial clear depending on steps per spin - constant is full clear
        /// </summary>
        /// <returns>symbols that were Set</returns>
        internal NodeDisplaySymbolContainer[] SetDisplaySymbolsForNextSpin()
        {
            BaseObjectGroupManager tempThis = this;
            //Hook into End Configuration Manager and get display symbols for this object manager
            EndConfigurationManager.instance.SetDisplaySymbolsForGroup(ref tempThis);
            //Used to get the symbol spin type and the set end display symbols for stepper strip what the strip will look like after 1 spin
            //Get from Spin type how many how many slots in object group to persist based on # steps per spin or full clear grouppping
            return symbolsDisplaySequence;
        }

        /// <summary>
        /// Set the slots in reel movement
        /// </summary>
        /// <param name="enable_disable">Set Slot movement enabled or disabled</param>
        internal void SetSlotsMovementEnabled(bool enable_disable)
        {
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].SetObjectMovementEnabledTo(enable_disable);
            }
        }

        internal int ReturnValidActiveDisplayFromRow(int row)
        {
            //Check if row entered passes active display zone - then check up and down
            if(IsRowInActiveDisplayZone(row))
            {
                return row;
            }
            else if(IsRowInActiveDisplayZone(row+1))
            {
                return row + 1;
            }
            else if(IsRowInActiveDisplayZone(row-1))
                return row - 1;
            else
            {
                Debug.LogWarning($"ReturnValidActiveDisplayFromRow is returning -1 - no valid rows. may cause unforseen issues");
                return -1;
            }
        }

        private bool IsRowInActiveDisplayZone(int row)
        {
            bool output = configurationGroupDisplayZones.IsRowInActiveDisplayZone(row);
            //Debug.Log($"{gameObject.name} is row {row} in active display = {output}");
            return output;
        }

        /// <summary>
        /// Set slots to Stop Spin
        /// </summary>
        private void SetSlotsToStopSpinning()
        {
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                //Last slot needs to ease in and out to the "next position" but 
                objectsInGroup[i].SetToStopSpin(); // Tween to the same position then evaluate\
            }
        }
        /// <summary>
        /// Instant sets a slot of reel to a configuration
        /// </summary>
        /// <param name="reelStripStruct"></param>
        internal void SetSymbolEndSymbolsAndDisplay(GroupSpinInformationStruct reelStripStruct)
        {
            endSymbolsSetFromConfiguration = 0;
            BaseObjectManager[] slotsDecendingOrder = GetSlotsDecending().ToArray();
            Debug.Log($"{gameObject.name} slotsDecendingOrder.Length = {slotsDecendingOrder.Length} Slot Order = {PrintGameObjectNames(slotsDecendingOrder)}");
            Debug.Log($"reelStripStruct.displaySymbols.Length = {reelStripStruct.displaySymbolsToLoad.Length}");

            List<NodeDisplaySymbolContainer> symbolsToDisplay = new List<NodeDisplaySymbolContainer>();
            for (int symbol = 0; symbol < reelStripStruct.displaySymbolsToLoad.Length; symbol++)
            {
                symbolsToDisplay.Add(reelStripStruct.displaySymbolsToLoad[symbol]);
            }
            Debug.Log($"symbolsToDisplay.Count = {symbolsToDisplay.Count}");

            SetEndingSymbolsTo(symbolsToDisplay.ToArray());

            Debug.Log($"configurationGroupDisplayZones.paddingBefore {configurationGroupDisplayZones.paddingBefore}");
            //Get padding before reel and set slots for all slots on matrix
            for (int slot = 0; slot < slotsDecendingOrder.Length; slot++)
            {
                if (slot < configurationGroupDisplayZones.paddingBefore)
                {
                    slotsDecendingOrder[slot].SetDisplaySymbolTo(reelStripStruct.displaySymbolsToLoad[endSymbolsSetFromConfiguration]);
                }
                else
                {
                    Debug.Log($"Setting {slotsDecendingOrder[slot].gameObject.name} to symbol reelStripStruct.displaySymbols[{endSymbolsSetFromConfiguration}]");
                    slotsDecendingOrder[slot].SetDisplaySymbolTo(reelStripStruct.displaySymbolsToLoad[endSymbolsSetFromConfiguration]);
                    endSymbolsSetFromConfiguration += 1;
                }
            }
        }

        private string PrintGameObjectNames(BaseObjectManager[] slotsDecendingOrder)
        {
            string output = "";
            for (int i = 0; i < slotsDecendingOrder.Length; i++)
            {
                output += slotsDecendingOrder[i].gameObject.name;
            }
            return output;
        }

        internal virtual List<BaseObjectManager> GetSlotsDecending()
        {
            Debug.Log($"Using Base Class Get Slots Decending foir {gameObject.name}");
            //Use sqr magnitude
            List<BaseObjectManager> output = new List<BaseObjectManager>();
            output.AddRange(objectsInGroup);
            output.Sort(); // Temporary sorting method - only ascending
            //Not efficient but gets the job done for 5-7 objects
            
            return output;
        }
        /// <summary>
        /// Sets the reel to end state and slots to end configuration
        /// </summary>
        public async Task StopReel()
        {
            endSymbolsSetFromConfiguration = 0;
            //Set State to spin outro
            SetSpinStateTo(SpinStates.spin_outro);
            //Waits until all slots have stopped spinning
            await StopReel(symbolsDisplaySequence); //This will control how fast the reel goes to stop spin
            SetSpinStateTo(SpinStates.spin_end);
        }
        /// <summary>
        /// Gets the display sequence of symbols in object group
        /// </summary>
        /// <returns></returns>
        internal NodeDisplaySymbolContainer[] GetNodeDisplaySymbols()
        {
            //Uncomment to use symbol display sequence that was pre-generated
            return symbolsDisplaySequence;
            //Debug.Log($"{gameObject.name} is generating Node Display Symbols");
            //List<BaseObjectManager> tempOutput = GetSlotsDecending();
            ////Debug.Log($"tempOutput.Count = {tempOutput.Count}");
            //List<NodeDisplaySymbolContainer> output = new List<NodeDisplaySymbolContainer>();
            //for (int i = 0; i < tempOutput.Count; i++) //TODO Refactor evaluations manager to not include padding rowint i = configurationGroupDisplayZones.paddingBefore ; i < tempOutput.Count; i++)
            //{
            //    //Debug.Log($"tempOutput[{i}].currentPresentingSymbolID = {tempOutput[i].currentPresentingSymbolID}");
            //    output.Add(new NodeDisplaySymbolContainer(tempOutput[i].currentPresentingSymbolID));
            //}
            ////Debug.Log($"Node Display Symbols from {gameObject.name} = {PrintNodeDisplaySymbols(output.ToArray())}");
            //return output.ToArray();
        }

        private string PrintNodeDisplaySymbols(NodeDisplaySymbolContainer[] nodeDisplaySymbols)
        {
            string output = "";
            for (int i = 0; i < nodeDisplaySymbols.Length; i++)
            {
                output += "|" + nodeDisplaySymbols[i].primarySymbol;
            }
            return output;
        }

        /// <summary>
        /// Stop the reel and set ending symbols
        /// </summary>
        /// <param name="ending_symbols">the symbols to land on</param>
        public async Task StopReel(NodeDisplaySymbolContainer[] ending_symbols)
        {
            //If not directional constant then whatever symbol is on reel right now use that
            SetEndingSymbolsTo(ending_symbols);
            SetSlotsToStopSpinning(); //When slots move to the top of the reel then assign the next symbol in list as name and delete from list
            await AllSlotsStoppedSpinning();
            objectGroupEndSpin?.Invoke(indexInGroupManager);
            //Debug.Log(String.Format("All slots stopped spinning for reel {0}",transform.name));
        }
        /// <summary>
        /// Set ending 
        /// </summary>
        /// <param name="endingSymbols">ending symbols for reelstrip</param>
        private void SetEndingSymbolsTo(NodeDisplaySymbolContainer[] endingSymbols)
        {
            Debug.Log($"Setting End Symbols To {PrintNodeDisplaySymbolArray(endingSymbols)} deprecated and set on start spin");
            //this.symbolsDisplaySequence = endingSymbols;
        }

        private string PrintNodeDisplaySymbolArray(NodeDisplaySymbolContainer[] endingSymbols)
        {
            List<int> output = new List<int>();
            for (int endingSymbol = 0; endingSymbol < endingSymbols.Length; endingSymbol++)
            {
                output.Add(endingSymbols[endingSymbol].primarySymbol);
            }
            return String.Join("|", output);
        }

        internal void SetAllSlotContainersAnimatorSyncStates()
        {
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                objectsInGroup[slot].SetStateMachineAnimators();
            }
        }

        internal void AddSlotAnimatorsToList(ref List<Animator> output)
        {
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                objectsInGroup[slot].AddAnimatorsToList(ref output);
            }
        }
        internal async Task AllSlotsStoppedSpinning()
        {
            //Debug.Log($"Waiting for group {gameObject.name} to stop spinning");
            bool task_lock = true;
            while (task_lock)
            {
                if (areObjectsInEndPosition)
                    await Task.Delay(100);
                else
                {
                    task_lock = false;
                }
            }
            //Debug.Log($"group {gameObject.name} stopped spinning");
        }

        //internal virtual void GenerateLocalPositions(ConfigurationSettingsScriptableObject configurationSettings)
        //{
        //    throw new NotImplementedException();
        //}

        internal void SetAllSlotContainersSubAnimatorStates()
        {
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                objectsInGroup[slot].SetAllSubStateAnimators();
            }
        }

        internal void ClearAllSlotContainersSubAnimatorStates()
        {
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                objectsInGroup[slot].ClearAllSubStateAnimators();
            }
        }

        internal AnimatorSubStateMachine[] ReturnAllValuesFromSubStates()
        {
            List<AnimatorSubStateMachine> values = new List<AnimatorSubStateMachine>();
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                values.AddRange(objectsInGroup[slot].animatorStateMachine.animator_state_machines.sub_state_machines_values.sub_state_machines);
            }
            return values.ToArray();
        }
        internal string[] ReturnAllKeysFromSubStates()
        {
            List<string> keys = new List<string>();
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                keys.AddRange(objectsInGroup[slot].animatorStateMachine.animator_state_machines.sub_state_machines_keys);
            }
            return keys.ToArray();
        }

        /// <summary>
        /// Sets the next symbol when a symbol reachs end of path
        /// </summary>
        /// <param name="selectedSymbolToGenerate"></param>
        internal void SetNextSymbolToSetOnLoopPath(int selectedSymbolToGenerate)
        {
            if (Application.isPlaying)
            {
                if (debugNextSymbolsToLoad == null)
                    debugNextSymbolsToLoad = new List<int>();
                debugNextSymbolsToLoad.Insert(0, selectedSymbolToGenerate);
            }
            else
            {
                List<BaseObjectManager> temp = GetSlotsDecending();
                Debug.Log($"Setting {gameObject.name} temp[0].gameObject.name = {temp[0].gameObject.name}");
                //Get slots descending and set the first padding symbol to next symbol
                NodeDisplaySymbolContainer temp2 = new NodeDisplaySymbolContainer(selectedSymbolToGenerate);
                temp[0].SetDisplaySymbolTo(temp2);

            }
        }
        internal void SyncInformationToDisplaySymbol ()
        {
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].SyncCurrentDisplaySymbolInfo();
            }
        }

        internal void SyncDisplaySymbolInformation()
        {
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].SyncCurrentDisplaySymbolInfo();
            }
        }

        internal void SetRandomDisplaySymbolAll()
        {
            for (int groupObject = 0; groupObject < objectsInGroup.Length; groupObject++)
            {
                objectsInGroup[groupObject].ShowRandomSymbol(); 
            }
        }

        internal void RegenerateSlots()
        {
            //Destroy Children
            for (int slot = transform.childCount - 1; slot >= 0 ; slot--)
            {
                DestroyImmediate(transform.GetChild(slot).gameObject);
            }
            for (int slot = 0; slot < configurationGroupDisplayZones.slotsToGenerate; slot++)
            {
                BaseObjectGroupManager temp = this;
                ConfigurationGenerator.GenerateSlotObject(slot,ref temp);
            }
        }

        internal void SetSlotsReference()
        {
            objectsInGroup = GetComponentsInChildren<BaseObjectManager>();
        }

        internal void SetDisplaySymbolsForNextSpinToCurrent()
        {
            List<BaseObjectManager> slots = GetSlotsDecending();
            symbolsDisplaySequence = new NodeDisplaySymbolContainer[slots.Count];
            for (int i = 0; i < slots.Count; i++)
            {
                symbolsDisplaySequence[i] = new NodeDisplaySymbolContainer(slots[i].currentPresentingSymbolID);
            }
        }

        internal void SetDisplaySymbolsToCurrentSequence()
        {
            SetObjectsDisplaySymbolsToSequence(objectsInGroup);
        }

        internal void SetObjectsDisplaySymbolsToSequence(BaseObjectManager[] objectsInGroup)
        {
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].SetDisplaySymbolTo(symbolsDisplaySequence[i]);
            }
        }
    }
}
