//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Reel.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
using System.Threading.Tasks;
using System;
using System.Collections.Generic;

namespace BoomSports.Prototype.Managers
{
    /// <summary>
    /// Base class 
    /// </summary>
    public class BaseObjectGroupManager : MonoBehaviour
    {
        /// <summary>
        /// Used to send an event that an object group has started/stopped spin and which one
        /// </summary>
        /// <param name="objectNumber"></param>
        public delegate void ObjectGroupEventEvent(int objectNumber);
        public event ObjectGroupEventEvent objectGroupStartSpin;
        public event ObjectGroupEventEvent objectGroupEndSpin;
        /// <summary>
        /// current spinState of Group
        /// </summary>
        [SerializeField]
        internal SpinStates currentSpinState;
        /// <summary>
        /// Index of group manager in parent array
        /// </summary>
        [SerializeField]
        public int indexInGroupManager;
        /// <summary>
        /// Display Zones for group
        /// </summary>
        [SerializeField]
        public ConfigurationDisplayZonesStruct configurationGroupDisplayZones;
        [SerializeField]
        internal BaseConfigurationObjectManager configurationObjectParent;
        /// <summary>
        /// Object managers in Group
        /// </summary>
        [SerializeField] //If base inspector enabled can check references
        internal BaseObjectManager[] objectsInGroup;
        /// <summary>
        /// Used to set the next symbol to display - stepper strip will set 1 # steps per spin - directional constant will set based on group length in active display zone
        /// </summary>
        [SerializeField]
        internal NodeDisplaySymbolContainer[] symbolsDisplaySymbolsSequence;
        /// <summary>
        /// When an object is moves from last position to first the symbol is changed.
        /// </summary>
        public List<int> nextSymbolToUseOnGoToStart;
        /// <summary>
        /// Enables you to change the symbol graphic when slot exits the viewable area of a configuration to a predefined strip or random draw weighte distribution symbol
        /// </summary>
        [SerializeField]
        public bool randomSetSymbolOnEndOfSequence = true;
        /// <summary>
        /// UI Indicator to ensure operation for setting symbols to end configuration has performed
        /// </summary>
        [SerializeField]
        internal int endSymbolsSetFromConfiguration = 0;
        [SerializeField]
        internal GroupInformationStruct stripInfo;
        internal bool areObjectsInEndPosition
        {
            get
            {
                bool output = true;
                for (int i = 0; i < objectsInGroup.Length; i++)
                {
                    if (!objectsInGroup[i].objectInEndPosition)
                    {
                        break;
                    }
                    if (i == objectsInGroup.Length - 1)
                    {
                        output = false;
                    }
                }
                return output;
            }
        }
        /// <summary>
        /// Symbols that activate slot features - Trailing multiplier in cash crossing lights up the plus sign on enter
        /// </summary>
        public ObjectGroupConditionalActivatorsContainer objectGroupConditionalActivatorsContainer;
        
        ///// <summary>
        ///// Structure for tracking slots in group that have symbols that activate features
        ///// </summary>
        //[Serializable]
        //public struct ActivatorTracker
        //{
        //    /// <summary>
        //    /// Symbol being tracked
        //    /// </summary>
        //    [SerializeField]
        //    public int symbol;
        //    /// <summary>
        //    /// Tracks which index's on strip the symbol is currently on
        //    /// </summary>
        //    [SerializeField]
        //    public int[] indexsSymbolResidesInStrip;
        //}

        ///// <summary>
        ///// Tracks which index in object group symbol activator is in. if there are multiple will track by symbol
        ///// </summary>
        //internal List<ActivatorTracker> activatorObjectGroupSymbolIndex
        //{
        //    get
        //    {
        //        if (_activatorObjectGroupSymbolIndex == null)
        //            _activatorObjectGroupSymbolIndex = new List<ActivatorTracker>();
        //        return _activatorObjectGroupSymbolIndex;
        //    }
        //}
        ///// <summary>
        ///// Tracks which index in object group symbol activator is in. if there are multiple will track by symbol
        ///// </summary>
        //[SerializeField]
        //internal List<ActivatorTracker> _activatorObjectGroupSymbolIndex;
        ///// <summary>
        ///// Used to recieve events from the strip with symbol that activated
        ///// </summary>
        //public void OnSlotActivatorEnterTriggered(int symbolEnter)
        //{
        //    //Find all index of slots triggering and trigger connected object
        //}
        /// <summary>
        /// Used to recieve events from the strip with symbol that activated
        /// </summary>
        //public void OnSlotActivatorExitTriggered(int symbolExit)
        //{
        //    //Find the index of slot triggered and trigger feature bridge animator in slot
        //}
        

        internal void ConditionalCheckNextSlotInPathFrom(BaseObjectManager baseObjectManager)
        {
            //get current position in path and next position in path
            //baseObjectManager.
            //Get position of object ini strip and check if next position in path Evaluates to true
            //Conditional check for Multiplier - Always - OnSlotEnter - Symbol Name Contains SA02
        }

        /// <summary>
        /// is the reel in a spin state
        /// </summary>
        internal bool isSpinning
        {
            get
            {
                bool output = true;
                if (objectsInGroup != null)
                {
                    for (int slot = 0; slot <= objectsInGroup.Length; slot++)
                    {
                        if (slot < objectsInGroup.Length)
                        {
                            if (objectsInGroup[slot] != null)
                            {
                                if (slot == objectsInGroup.Length)
                                {
                                    output = false;
                                    break;
                                }
                                if (objectsInGroup[slot].spinMovementEnabled)
                                {
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    return false;
                }
                return output;
            }
        }
        public bool registerStartSpinWithObjectsEvent = true;
        public bool registerOnNextSymbolChangeWithObjectsEvent = false;
        public void OnEnable()
        {
            RegisterWithObjectsInGroupEvents();
        }

        private void RegisterWithObjectsInGroupEvents()
        {
            if (registerStartSpinWithObjectsEvent || registerOnNextSymbolChangeWithObjectsEvent)
            {
                for (int groupedObject = 0; groupedObject < objectsInGroup.Length; groupedObject++)
                {
                    if(registerStartSpinWithObjectsEvent)
                    {
                        objectsInGroup[groupedObject].startSpinCheckNextPointInPath += BaseObjectGroupManager_startSpinCheckNextPointInPath;
                    }
                }
            }
        }
        /// <summary>
        /// Right now used for stepper reel specifically to check next symbol in path
        /// </summary>
        /// <param name="objectInPath"></param>
        private void BaseObjectGroupManager_startSpinCheckNextPointInPath(BaseObjectManager objectInPath)
        {
            BaseSlotActivatorEventConditional[] conditionalsToCheck = objectGroupConditionalActivatorsContainer.GetAllConditionalChecks();
            //Iterate thru evaluators and evaluate for a true condition
            for (int i = 0; i < conditionalsToCheck.Length; i++)
            {
                if(conditionalsToCheck[i].EvaluateCondition(objectInPath))
                {
                    //Cash-Crossing Specific - Send signal to bridge manager to set bonus pulse to idle
                    Debug.Log($"{gameObject.name} {objectInPath.gameObject.name} Activated Slot Condition -TODO label add slot conditional active");
                }
            }
        }

        public void OnDisable()
        {
            DeregisterWithObjectsInGroupEvents();
        }

        private void DeregisterWithObjectsInGroupEvents()
        {
            if (registerStartSpinWithObjectsEvent || registerOnNextSymbolChangeWithObjectsEvent)
            {
                for (int groupedObject = 0; groupedObject < objectsInGroup.Length; groupedObject++)
                {
                    if (registerStartSpinWithObjectsEvent)
                    {
                        objectsInGroup[groupedObject].startSpinCheckNextPointInPath -= BaseObjectGroupManager_startSpinCheckNextPointInPath;
                    }
                }
            }
        }

        /// <summary>
        /// Spin the Reels
        /// </summary>
        /// <returns>async task to track</returns>
        public virtual Task StartSpin()
        {
            objectGroupStartSpin?.Invoke(indexInGroupManager);
            //Clear Ending Symbols - Set new ending symbols
            InitializeEndingDisplayForNewSpin();
            //Switching to ObjectManager of spin object to invoke check of display symbol and row in strip.
            //Check each symbols next position - any symbol activating a condition send event to recieving object
            //CheckEvaluationConditionsFromEndDisplayConfiguration();

            SetSpinStateTo(SpinStates.spin_start);

            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].StartSpin();
            }
            //If event on symbol stop then evaluate if event conidtions were reached - ie SpinDirectionalStepper a bonus trigger will land on the strip and a + will glow symbo
            //TODO refactor check for interupt state
            SetSpinStateTo(SpinStates.spin_idle);
            return Task.CompletedTask;
        }
        /// <summary>
        /// Gets the number of symbols in a group that will be replaced on a spin
        /// </summary>
        /// <returns></returns>
        internal int GetSymbolsToBeReplacedPerSpin()
        {
            //Access Spin Parameters and get number of symbols to replace per spin
            return configurationGroupDisplayZones.spinParameters.GetSymbolsReplacedPerSpin(objectsInGroup.Length);
            //Ex: stepper replaces x symbols x=steps per spin allowed. Directional Constant is full strip clear
        }

        internal string PrintCurrentDisplaySymbols()
        {
            string output = "";
            List<BaseObjectManager> lastInFirstOut = GetSlotsDecending();
            for (int i = 0; i < lastInFirstOut.Count; i++)
            {
                output += $"|{lastInFirstOut[i].currentPresentingSymbolID}";
            }
            return output;
        }

        internal int GetIndexInGroup()
        {
            return configurationObjectParent.GetIndexOfGroupManager(this);
        }

        /// <summary>
        /// Spin the Reels
        /// </summary>
        /// <returns>async task to track</returns>
        public void SpinGroupNow(bool test = false)
        {
            InitializeEndingDisplayForNewSpin();

            //When reel is generated it's vector3[] path is generated for reference from slots
            SetSpinStateTo(SpinStates.spin_start);
            //TODO hooks for reel state machine
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                //Last slot needs to ease in and out to the "next position" but 
                objectsInGroup[i].StartSpin(test); // Tween to the same position then evaluate
            }
            //Task.Delay(time_to_enter_loop);
            //TODO Implement Ease In for Starting spin
            //TODO refactor check for interupt state
            SetSpinStateTo(SpinStates.spin_idle);
        }
        /// <summary>
        /// Sets the Spin State to state
        /// </summary>
        /// <param name="state">SpinStates state to set reel to</param>
        private void SetSpinStateTo(SpinStates state)
        {
            currentSpinState = state;
        }
        /// <summary>
        /// Initializes Ending Display Symbols for Strip.
        /// </summary>
        internal void InitializeEndingDisplayForNewSpin()
        {
            symbolsDisplaySymbolsSequence = GetDisplaySymbolsForNextSpin();
        }
        /// <summary>
        /// Gets the display slots for the next spin - Stepper is partial clear depending on steps per spin - constant is full clear
        /// </summary>
        /// <returns></returns>
        private NodeDisplaySymbolContainer[] GetDisplaySymbolsForNextSpin()
        {
            BaseObjectGroupManager tempThis = this;
            //Hook into End Configuration Manager and get display symbols for this object manager
            EndConfigurationManager.instance.SetDisplaySymbolsForGroup(ref tempThis);
            //Used to get the symbol spin type and the set end display symbols for stepper strip what the strip will look like after 1 spin
            //Get from Spin type how many how many slots in object group to persist based on # steps per spin or full clear grouppping
            return symbolsDisplaySymbolsSequence;
        }

        /// <summary>
        /// Set the slots in reel movement
        /// </summary>
        /// <param name="enable_disable">Set Slot movement enabled or disabled</param>
        internal void SetSlotsMovementEnabled(bool enable_disable)
        {
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].SetObjectMovementEnabledTo(enable_disable);
            }
        }

        internal int ReturnValidActiveDisplayFromRow(int row)
        {
            //Check if row entered passes active display zone - then check up and down
            if(IsRowInActiveDisplayZone(row))
            {
                return row;
            }
            else if(IsRowInActiveDisplayZone(row+1))
            {
                return row + 1;
            }
            else if(IsRowInActiveDisplayZone(row-1))
                return row - 1;
            else
            {
                Debug.LogWarning($"ReturnValidActiveDisplayFromRow is returning -1 - no valid rows. may cause unforseen issues");
                return -1;
            }
        }

        private bool IsRowInActiveDisplayZone(int row)
        {
            bool output = configurationGroupDisplayZones.IsRowInActiveDisplayZone(row);
            //Debug.Log($"{gameObject.name} is row {row} in active display = {output}");
            return output;
        }

        /// <summary>
        /// Set slots to Stop Spin
        /// </summary>
        private void SetSlotsToStopSpinning()
        {
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                //Last slot needs to ease in and out to the "next position" but 
                objectsInGroup[i].SetToStopSpin(); // Tween to the same position then evaluate\
            }
        }
        /// <summary>
        /// Instant sets a slot of reel to a configuration
        /// </summary>
        /// <param name="reelStripStruct"></param>
        internal void SetSymbolEndSymbolsAndDisplay(GroupSpinInformationStruct reelStripStruct)
        {
            endSymbolsSetFromConfiguration = 0;
            BaseObjectManager[] slotsDecendingOrder = GetSlotsDecending().ToArray();
            Debug.Log($"{gameObject.name} slotsDecendingOrder.Length = {slotsDecendingOrder.Length} Slot Order = {PrintGameObjectNames(slotsDecendingOrder)}");
            Debug.Log($"reelStripStruct.displaySymbols.Length = {reelStripStruct.displaySymbolSequence.Length}");

            List<NodeDisplaySymbolContainer> symbolsToDisplay = new List<NodeDisplaySymbolContainer>();
            for (int symbol = 0; symbol < reelStripStruct.displaySymbolSequence.Length; symbol++)
            {
                symbolsToDisplay.Add(reelStripStruct.displaySymbolSequence[symbol]);
            }
            Debug.Log($"symbolsToDisplay.Count = {symbolsToDisplay.Count}");

            SetEndingSymbolsTo(symbolsToDisplay.ToArray());

            Debug.Log($"configurationGroupDisplayZones.paddingBefore {configurationGroupDisplayZones.paddingBefore}");
            //Get padding before reel and set slots for all slots on matrix
            for (int slot = 0; slot < slotsDecendingOrder.Length; slot++)
            {
                if (slot < configurationGroupDisplayZones.paddingBefore)
                {
                    slotsDecendingOrder[slot].SetDisplaySymbolTo(reelStripStruct.displaySymbolSequence[endSymbolsSetFromConfiguration]);
                }
                else
                {
                    Debug.Log($"Setting {slotsDecendingOrder[slot].gameObject.name} to symbol reelStripStruct.displaySymbols[{endSymbolsSetFromConfiguration}]");
                    slotsDecendingOrder[slot].SetDisplaySymbolTo(reelStripStruct.displaySymbolSequence[endSymbolsSetFromConfiguration]);
                    endSymbolsSetFromConfiguration += 1;
                }
            }
        }

        private string PrintGameObjectNames(BaseObjectManager[] slotsDecendingOrder)
        {
            string output = "";
            for (int i = 0; i < slotsDecendingOrder.Length; i++)
            {
                output += slotsDecendingOrder[i].gameObject.name;
            }
            return output;
        }

        internal virtual List<BaseObjectManager> GetSlotsDecending()
        {
            Debug.Log($"Using Base Class Get Slots Decending foir {gameObject.name}");
            //Use sqr magnitude
            List<BaseObjectManager> output = new List<BaseObjectManager>();
            output.AddRange(objectsInGroup);
            output.Sort(); // Temporary sorting method - only ascending
            //Not efficient but gets the job done for 5-7 objects
            
            return output;
        }
        /// <summary>
        /// Sets the reel to end state and slots to end configuration
        /// </summary>
        public async Task StopReel(GroupSpinInformationStruct reelStrip)
        {
            endSymbolsSetFromConfiguration = 0;
            //Set State to spin outro
            SetSpinStateTo(SpinStates.spin_outro);
            //Waits until all slots have stopped spinning
            await StopReel(reelStrip.displaySymbolSequence); //This will control ho wfast the reel goes to stop spin
            SetSpinStateTo(SpinStates.spin_end);
        }

        internal NodeDisplaySymbolContainer[] GetNodeDisplaySymbols()
        {
            //Debug.Log($"{gameObject.name} is generating Node Display Symbols");
            List<BaseObjectManager> tempOutput = GetSlotsDecending();
            //Debug.Log($"tempOutput.Count = {tempOutput.Count}");
            List<NodeDisplaySymbolContainer> output = new List<NodeDisplaySymbolContainer>();
            for (int i = 0; i < tempOutput.Count; i++) //TODO Refactor evaluations manager to not include padding rowint i = configurationGroupDisplayZones.paddingBefore ; i < tempOutput.Count; i++)
            {
                //Debug.Log($"tempOutput[{i}].currentPresentingSymbolID = {tempOutput[i].currentPresentingSymbolID}");
                output.Add(new NodeDisplaySymbolContainer(tempOutput[i].currentPresentingSymbolID));
            }
            //Debug.Log($"Node Display Symbols from {gameObject.name} = {PrintNodeDisplaySymbols(output.ToArray())}");
            return output.ToArray();
        }

        private string PrintNodeDisplaySymbols(NodeDisplaySymbolContainer[] nodeDisplaySymbols)
        {
            string output = "";
            for (int i = 0; i < nodeDisplaySymbols.Length; i++)
            {
                output += "|" + nodeDisplaySymbols[i].primarySymbol;
            }
            return output;
        }

        /// <summary>
        /// Stop the reel and set ending symbols
        /// </summary>
        /// <param name="ending_symbols">the symbols to land on</param>
        public async Task StopReel(NodeDisplaySymbolContainer[] ending_symbols)
        {
            //If not directional constant then whatever symbol is on reel right now use that
            SetEndingSymbolsTo(ending_symbols);
            SetSlotsToStopSpinning(); //When slots move to the top of the reel then assign the next symbol in list as name and delete from list
            await AllSlotsStoppedSpinning();
            objectGroupEndSpin?.Invoke(indexInGroupManager);
            //Debug.Log(String.Format("All slots stopped spinning for reel {0}",transform.name));
        }
        /// <summary>
        /// Set Ending Symbols variable
        /// </summary>
        /// <param name="endingSymbols">ending symbols for reelstrip</param>
        private void SetEndingSymbolsTo(NodeDisplaySymbolContainer[] endingSymbols)
        {
            //Debug.Log($"Setting End Symbols To {PrintNodeDisplaySymbolArray(endingSymbols)}");
            this.symbolsDisplaySymbolsSequence = endingSymbols;
        }

        private string PrintNodeDisplaySymbolArray(NodeDisplaySymbolContainer[] endingSymbols)
        {
            List<int> output = new List<int>();
            for (int endingSymbol = 0; endingSymbol < endingSymbols.Length; endingSymbol++)
            {
                output.Add(endingSymbols[endingSymbol].primarySymbol);
            }
            return String.Join("|", output);
        }

        internal void SetAllSlotContainersAnimatorSyncStates()
        {
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                objectsInGroup[slot].SetStateMachineAnimators();
            }
        }

        internal void AddSlotAnimatorsToList(ref List<Animator> output)
        {
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                objectsInGroup[slot].AddAnimatorsToList(ref output);
            }
        }
        internal async Task AllSlotsStoppedSpinning()
        {
            //Debug.Log($"Waiting for group {gameObject.name} to stop spinning");
            bool task_lock = true;
            while (task_lock)
            {
                if (areObjectsInEndPosition)
                    await Task.Delay(100);
                else
                {
                    task_lock = false;
                }
            }
            //Debug.Log($"group {gameObject.name} stopped spinning");
        }

        //internal virtual void GenerateLocalPositions(ConfigurationSettingsScriptableObject configurationSettings)
        //{
        //    throw new NotImplementedException();
        //}

        internal void SetAllSlotContainersSubAnimatorStates()
        {
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                objectsInGroup[slot].SetAllSubStateAnimators();
            }
        }

        internal void ClearAllSlotContainersSubAnimatorStates()
        {
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                objectsInGroup[slot].ClearAllSubStateAnimators();
            }
        }

        internal AnimatorSubStateMachine[] ReturnAllValuesFromSubStates()
        {
            List<AnimatorSubStateMachine> values = new List<AnimatorSubStateMachine>();
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                values.AddRange(objectsInGroup[slot].animatorStateMachine.animator_state_machines.sub_state_machines_values.sub_state_machines);
            }
            return values.ToArray();
        }
        internal string[] ReturnAllKeysFromSubStates()
        {
            List<string> keys = new List<string>();
            for (int slot = 0; slot < objectsInGroup.Length; slot++)
            {
                keys.AddRange(objectsInGroup[slot].animatorStateMachine.animator_state_machines.sub_state_machines_keys);
            }
            return keys.ToArray();
        }

        /// <summary>
        /// Sets the next symbol when a symbol reachs end of path
        /// </summary>
        /// <param name="selectedSymbolToGenerate"></param>
        internal void SetNextSymbolToSetOnLoopPath(int selectedSymbolToGenerate)
        {
            if (Application.isPlaying)
            {
                if (nextSymbolToUseOnGoToStart == null)
                    nextSymbolToUseOnGoToStart = new List<int>();
                nextSymbolToUseOnGoToStart.Insert(0, selectedSymbolToGenerate);
            }
            else
            {
                List<BaseObjectManager> temp = GetSlotsDecending();
                Debug.Log($"Setting {gameObject.name} temp[0].gameObject.name = {temp[0].gameObject.name}");
                //Get slots descending and set the first padding symbol to next symbol
                NodeDisplaySymbolContainer temp2 = new NodeDisplaySymbolContainer(selectedSymbolToGenerate);
                temp[0].SetDisplaySymbolTo(temp2);

            }
        }
        internal void SyncInformationToDisplaySymbol ()
        {
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].SyncCurrentDisplaySymbolInfo();
            }
        }

        internal void SyncDisplaySymbolInformation()
        {
            for (int i = 0; i < objectsInGroup.Length; i++)
            {
                objectsInGroup[i].SyncCurrentDisplaySymbolInfo();
            }
        }

        internal void SetRandomDisplaySymbolAll()
        {
            for (int groupObject = 0; groupObject < objectsInGroup.Length; groupObject++)
            {
                objectsInGroup[groupObject].ShowRandomSymbol(); 
            }
        }

        internal void RegenerateSlots()
        {
            //Destroy Children
            for (int slot = transform.childCount - 1; slot >= 0 ; slot--)
            {
                DestroyImmediate(transform.GetChild(slot).gameObject);
            }
            for (int slot = 0; slot < configurationGroupDisplayZones.slotsToGenerate; slot++)
            {
                BaseObjectGroupManager temp = this;
                ConfigurationGenerator.GenerateSlotObject(slot,ref temp);
            }
        }

        internal void SetSlotsReference()
        {
            objectsInGroup = GetComponentsInChildren<BaseObjectManager>();
        }
    }
}
