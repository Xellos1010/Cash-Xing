//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Slot.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif
namespace Slot_Engine.Matrix
{
#if UNITY_EDITOR
    [CustomEditor(typeof(Slot))]
    class SlotEditor : Editor
    {
        Slot myTarget;

        public void OnEnable()
        {
            myTarget = (Slot)target;
        }

        public override void OnInspectorGUI()
        {
            //base.OnInspectorGUI();
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("Commands");
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("Editable Properties");
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("To be Removed");
            base.OnInspectorGUI();

        }
    }
#endif
        public class Slot : MonoBehaviour
        {
        /// <summary>
        /// The symbol presenting after the reel stops
        /// </summary>
        public string presentation_symbol;
        public Reel reel_parent;
        public float time_in_path = 0.0f;

        public bool movement_enabled = false;
        /// <summary>
        /// the end position for the reels to calculate and land on
        /// </summary>
        public Vector3 end_position;
        public bool set_to_end_position = false;
        public bool graphics_set_to_end = false;
        public MeshRenderer _meshRenderer;


        public MeshRenderer meshRenderer
        {
            get
            {
                if (_meshRenderer == null)
                    _meshRenderer = GetComponentInChildren<MeshRenderer>();
                return _meshRenderer;
            }
        }

        //Unity Default Functions

        //*************
        /// <summary>
        /// Sets the material for the mesh renderer to new material
        /// </summary>
        /// <param name="to_material">material to set mesh renderer</param>
        public void SetMeshRendererMaterialTo(Material to_material)
        {
            meshRenderer.material = to_material;
        }
        /// <summary>
        /// Loads from Resources the symbol material
        /// </summary>
        /// <param name="to_symbol">the symbol name to look for</param>
        public void SetSlotGraphicTo(string to_symbol)
        {
            //TODO add test cases for if to_graphic is present in directory
            //TODO Add State Dependant Graphics Loading
            Material to_material = reel_parent.matrix.ReturnSymbolMaterial(to_symbol);
            SetMeshRendererMaterialTo(to_material);
        }

        public void PlayAnimation()
        {
            //Sprite.frameRate = 24;
            //Sprite.Play();
            //TODO Insert Play Animation Logic
        }

        public void StopAnimation()
        {
            //Sprite.frameRate = 24;
            //Sprite.Stop();
            //TODO Insert Stop Animation Logic
        }

        public void StartSpin()
        {
            //Debug.Log(gameObject.name + " starting Spin");
            ResetAllVars();
            StopAnimation();    
            movement_enabled = true;
        }
        
        //TODO update for omni directional
        private void SetTimeInPathByPosition(Vector3 localPosition)
        {
            SetTimeInPathTo(reel_parent.GenerateTimeInPath(localPosition.y, reel_parent.positions_in_path_v3[reel_parent.positions_in_path_v3.Length - 1].y));
        }

        private void SetTimeInPathTo(float new_time_in_path)
        {
            time_in_path = new_time_in_path;
        }

        Vector3 GeneratePositionUpdateTime(float time_on_path) //TODO remove
        {
            return reel_parent.GetLoopPositionFromTime(time_on_path);
        }
        Vector3 GeneratePositionUpdateSpeed(Vector3 amount_to_add) //Needs to be positive to move forwards and negative to move backwards
        {
            return transform.localPosition + amount_to_add; //new Vector3(transform.localPosition.x, transform.localPosition.y + amount_to_add, transform.localPosition.z);
        }
        void Update()
        {
            if (movement_enabled)
            {
                Vector3 toPosition;
                if (reel_parent.use_time_speed)
                {
                    time_in_path += Time.deltaTime;
                    if (time_in_path >= reel_parent.reel_spin_time)
                    {
                        time_in_path = reel_parent.reel_spin_time - time_in_path;
                    }
                    toPosition = GeneratePositionUpdateTime(time_in_path);
                }
                else
                {
                    toPosition = GeneratePositionUpdateSpeed(reel_parent.reel_spin_speed_loop_constant);
                    //Check X Y and Z and move slot to opposite

                    //Check if to far left or right and move

                    //Check if to far down or up and move
                    if (reel_parent.reel_spin_speed_loop_constant.y < 0)
                    {
                        if (toPosition.y <= reel_parent.positions_in_path_v3[reel_parent.positions_in_path_v3.Length - 1].y)
                            ShiftToPositionBy(ref toPosition, reel_parent.positions_in_path_v3[reel_parent.positions_in_path_v3.Length - 1], true);
                    }
                    else if (reel_parent.reel_spin_speed_loop_constant.y > 0)
                    {
                        if (toPosition.y >= reel_parent.positions_in_path_v3[0].y)
                            ShiftToPositionBy(ref toPosition, reel_parent.positions_in_path_v3[reel_parent.positions_in_path_v3.Length - 1], false);
                    }
                }
                //TODO Refactor to support omni directional #potentially with magnitude
                if(set_to_end_position && graphics_set_to_end)
                    if (toPosition.y <= end_position.y)
                    {
                        toPosition = end_position;
                        ResetAllVars();
                    }
                transform.localPosition = toPosition;
            }
        }

        private void ResetAllVars()
        {
            movement_enabled = false;
            set_to_end_position = false;
            graphics_set_to_end = false;
            //SetPresentationSymbolTo("");
        }


        private void ShiftToPositionBy(ref Vector3 toPosition, Vector3 lastPosition, bool upDown)
        {
            if(upDown)
                toPosition = new Vector3(toPosition.x,toPosition.y - lastPosition.y, toPosition.z);
            else
                toPosition = new Vector3(toPosition.x, toPosition.y + lastPosition.y, toPosition.z);

            if(set_to_end_position)
            {
                //Set Graphics and end position
                graphics_set_to_end = true;
                end_position = reel_parent.positions_in_path_v3[reel_parent.ending_symbols.Length];

                if (reel_parent.ending_symbols.Length > 0)
                {
                    SetDisplaySymbolTo(reel_parent.ending_symbols.Length - 1);
                    
                }
                else
                {
                    SetPresentationSymbolTo("Not on Matrix"); //TODO Define whether to set the top slot graphic
                }
                Debug.Log("Slot " + transform.name + " symbol presentation = " + presentation_symbol + " end position = " + end_position);
            }
            else
            {
                if (reel_parent.change_symbol_on_matrix_exit)
                {
                    SetSlotGraphicTo(reel_parent.matrix.supported_symbols[reel_parent.matrix.GetRandomSymbol()]);
                }
            }

        }

        internal void SetDisplaySymbolTo(int v)
        {
            Debug.Log(string.Format("Set Display symbol to {0}", v));
            SetPresentationSymbolTo(reel_parent.ending_symbols[v]);
            SetSlotGraphicTo(presentation_symbol);
            reel_parent.ending_symbols = StaticUtilities.RemoveAt<string>(reel_parent.ending_symbols, v);
        }

        private void SetPresentationSymbolTo(string to_symbol)
        {
            presentation_symbol = to_symbol;
        }

        internal void SetToStopSpin()
        {
            //TODO setup state machine
            set_to_end_position = true;
        }
    }
}