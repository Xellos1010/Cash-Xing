//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Matrix.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Slot_Engine.Matrix
{

#if UNITY_EDITOR
    [CustomEditor(typeof(Matrix))]
    class MatrixEditor : Editor
    {
        Matrix myTarget;
        SerializedProperty state;
        SerializedProperty reel_spin_delay_ms;
        SerializedProperty supported_symbols;
        SerializedProperty supported_symbols_materials;
        SerializedProperty ending_symbols;
        public void OnEnable()
        {
            myTarget = (Matrix)target;
            reel_spin_delay_ms = serializedObject.FindProperty("reel_spin_delay_ms");
            supported_symbols = serializedObject.FindProperty("supported_symbols");
            supported_symbols_materials = serializedObject.FindProperty("_supported_symbols_materials");
            ending_symbols = serializedObject.FindProperty("ending_symbols");
        }
        public override void OnInspectorGUI()
        {
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("Matrix Properties");

            EditorGUILayout.EnumPopup(StateManager.enCurrentState);
            EditorGUI.BeginChangeCheck();
            reel_spin_delay_ms.intValue = EditorGUILayout.IntSlider("Delay between reels star spin ms",reel_spin_delay_ms.intValue,0,2000);
            if (EditorGUI.EndChangeCheck())
            {
                serializedObject.ApplyModifiedProperties();
            }
            EditorGUILayout.PropertyField(supported_symbols);
            if(supported_symbols_materials.arraySize < supported_symbols.arraySize && !ElementsInArrayAreEmpty(supported_symbols_materials))
            {
                SetMaterialsReference();
            }
            EditorGUILayout.PropertyField(supported_symbols_materials);
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("Matrix Controls");
            if (Application.isPlaying)
            {
                if (GUILayout.Button("Start Test Spin"))
                {
                    myTarget.StartSpin();
                }
                if (GUILayout.Button("End Test Spin"))
                {
                    myTarget.EndSpin();
                }
            }
            else
            {
                if (GUILayout.Button("Generate Ending Symbols"))
                {
                    myTarget.GenerateEndReelStripsConfiguration();
                }
                if (GUILayout.Button("Set Symbols to End Symbols"))
                {
                    myTarget.SetReelStripsEndConfiguration();
                }
                if (GUILayout.Button("Display End Reels and Reset"))
                {
                    myTarget.DisplayEndingReelStrips();
                }
                if (GUILayout.Button("Find Symbol Materials"))
                {
                    SetMaterialsReference();
                }
            }
            BoomEditorUtilities.DrawUILine(Color.white);
            EditorGUILayout.LabelField("To Be Removed - Default inspector");
            base.OnInspectorGUI();
        }

        private void SetMaterialsReference()
        {
            myTarget.GenerateSupportedSymbolsMaterials();
            serializedObject.ApplyModifiedProperties();
            supported_symbols_materials = serializedObject.FindProperty("_supported_symbols_materials");
            serializedObject.ApplyModifiedProperties();
        }

        private bool ElementsInArrayAreEmpty(SerializedProperty supported_symbols_materials)
        {
            for (int i = 0; i < myTarget.supported_symbols_materials.Length; i++)
            {
                if (supported_symbols_materials.GetArrayElementAtIndex(supported_symbols_materials.arraySize - 1).objectReferenceValue == null)
                    return true;
            }
            return false;
        }
    }
#endif

    public class Matrix : MonoBehaviour
    {
        private PayLines paylines
        {
            get
            {
                if (_paylines == null)
                    _paylines = GetComponent<PayLines>();
                return _paylines;
            }
        }
        private PayLines _paylines;

        public string[] supported_symbols = new string[10] { "MA01", "MI01", "MI02", "MI03", "RO01", "RO02", "RO03", "SA_01", "SA_02", "BW01" }; //TODO Make available in matrix generator to define symbols supported

        public Material[] _supported_symbols_materials;
        public SerializableDictionary<string, Material> supported_symbols_map_materials;
        public SpinManager spin_manager;
        public Vector3[] matrix; //elements are reels value is slot per reel
        public Vector3 slot_size;
        public Vector3 padding;
        public float spin_speed;
        public int reel_spin_delay_ms = 0;
        public Vector2 reel_slot_padding = new Vector2(0, 1); //TODO set from Matrix Generator

        public Reel[] rReels;
        public ReelStrip[] endingSymbols;
        protected List<Symbols[]> _ReelSymbols;

        private List<Symbols[]> ReelSymbols
        {
            get
            {
                if (_ReelSymbols == null)
                    _ReelSymbols = GenerateEndReelsSymbols();
                if (_ReelSymbols.Count == 0)
                    _ReelSymbols = GenerateEndReelsSymbols();
                return _ReelSymbols;
            }
            set
            {
                _ReelSymbols = value;
            }
        }
        internal void ReturnSymbolPositionsOnPayline(ref Payline payline, out List<Vector3> linePositions)
        {
            linePositions = new List<Vector3>();
            for (int i = 0; i < rReels.Length; i++)
            {
                Vector3 position_cache = rReels[i].slots_in_reel[payline.payline[i] + 1].transform.position; //Top slot cushion slot - use 1 as first element - If more than 1 cushion slot change logic to pull display slots from -2 end of array. Slots move off screen
                position_cache = new Vector3(position_cache.x, position_cache.y, -10); //TODO Change Hardcoded Value
                                                                                       //TOOD change to get slot at position at path to return x and y
                linePositions.Add(position_cache);
            }
        }

        public Material[] supported_symbols_materials
        {
            get
            {
                if (_supported_symbols_materials == null || _supported_symbols_materials.Length < supported_symbols.Length)
                {
                    GenerateSupportedSymbolsMaterials();
                }
                return _supported_symbols_materials;
            }
        }
        /// <summary>
        /// Controls the wegihted probability of symbols appearing on the reel
        /// </summary>
        private WeightedDistribution.IntDistribution intWeightedDistributionSymbols
        {
            get
            {
                if(_intWeightedDistributionSymbols == null)
                {
                    _intWeightedDistributionSymbols = GetComponent<WeightedDistribution.IntDistribution>();
                }
                return _intWeightedDistributionSymbols;
            }
        }
        private WeightedDistribution.IntDistribution _intWeightedDistributionSymbols;


        public int GetRandomSymbol()
        {
            return intWeightedDistributionSymbols.Draw();
        }

        internal void GenerateSupportedSymbolsMaterials()
        {
            _supported_symbols_materials = new Material[supported_symbols.Length];
            supported_symbols_map_materials = new SerializableDictionary<string, Material>();
            for (int i = 0; i < supported_symbols.Length; i++)
            {
                Debug.Log(string.Format("Getting symbol {0}", supported_symbols[i]));
                _supported_symbols_materials[i] = Resources.Load<Material>("Materials/BaseGame/Symbols/" + supported_symbols[i]);
                supported_symbols_map_materials[supported_symbols[i]] = _supported_symbols_materials[i];
            }
        }

        internal Material ReturnSymbolMaterial(string to_symbol)
        {
            try
            {
                return supported_symbols_map_materials[to_symbol];
            }
            catch(Exception e)
            {
                Debug.Log(e.Message);
                Debug.Log(string.Format("key given = {0}",to_symbol));
                return null;
            }
        }

        //****Unity Default Functions

        void Start()
        {
            if (supported_symbols_map_materials == null)
            {
                GenerateSupportedSymbolsMaterials();
            }
        }

        void OnEnable()
        {
            StateManager.StateChangedTo += StateManager_StateChangedTo;
        }

        void OnDisable()
        {
            StateManager.StateChangedTo -= StateManager_StateChangedTo;
        }


        //***********

        private void StateManager_StateChangedTo(States State)
        {
            if (State == States.spin_start)
            {
                StartSpin();
            }
            else if (State == States.spin_end)
            {
                EndSpin();
            }
        }
        //TODO - Enable offset from 0,0,0
        public Task GenerateMatrix(Vector3[] matrix, Vector3 slot_size, Vector3 padding)
        {
            this.matrix = matrix;
            this.slot_size = slot_size;
            this.padding = padding;
            if (transform.childCount > 0) // Destroy old matrix if you have one
            {
                for (int i = transform.childCount - 1; i >= 0; i--)
                    DestroyImmediate(transform.GetChild(i).gameObject);
            }
            GenerateReels(matrix);
            return Task.CompletedTask;
        }

        private void GenerateReels(Vector3[] matrix)
        {
            List<Reel> newReelList = new List<Reel>();
            if (rReels == null)
                rReels = new Reel[0];
            newReelList.AddRange(rReels);
            if(newReelList.Count < matrix.Length)
            {
                for (int i = 0; i < matrix.Length; i++)
                {
                    if(i == newReelList.Count)
                    {
                        newReelList.Add(GenerateReel(i));
                    }
                    newReelList[i].UpdateSlotsInReel(matrix[i], this);
                }
            }
            rReels = newReelList.ToArray();
        }

        Reel GenerateReel(int reel_number)
        {
            //Create Reel Game Object
            Type[] ReelType = new Type[1];
            ReelType[0] = typeof(Reel);
            //Debug.Log("Creating Reel Number " + ReelNumber);
            Reel ReturnValue = new GameObject("Reel_" + reel_number, ReelType).GetComponent<Reel>();
            //Debug.Log("Setting Transform and Parent Reel-" + ReelNumber);
            //Position object in Game Space based on Reel Number Then set the parent
            ReturnValue.transform.parent = transform;
            ReturnValue.reel_number = reel_number;
            return ReturnValue;
        }
            
        public async void StartSpin()
        {
            //TODO refactor implement async and stop all tasks
            //StopAllCoroutines();
            //TODO setup State machine
            endingSymbols = GenerateEndReelStripsConfiguration().Result;
            paylines.EvaluateWinningSymbols(endingSymbols);
            //continuation = GenerateEndReelConfigurationTask.ContinueWith(t =>
            //{
            //    Console.WriteLine("Result: " + t.Result);
            //    endingSymbols = t.Result;
            //});
            SpinReels();
            //TODO setup async task 

        }
        /// <summary>
        /// Generates the Display matrix then runs payline evaluation
        /// </summary>
        /// <returns>Task.Completed</returns>
        internal async Task<ReelStrip[]> GenerateEndReelStripsConfiguration()
        {
            return GenerateSymbolsPerReel().Result;
        }
        
        internal Task<ReelStrip[]> GenerateSymbolsPerReel()
        {
            List<ReelStrip> output = new List<ReelStrip>();
            for (int reel = 0; reel < rReels.Length; reel++)
            {
                output.Add(new ReelStrip(GenerateEndingReelStrip(3))); // TODO change to scale slot size
            }
            return Task.FromResult<ReelStrip[]>(output.ToArray());
        }

        private int[] GenerateEndingReelStrip(int v)
        {
            List<int> output = new List<int>();
            for (int i = 0; i < v; i++)
            {
                output.Add(GetRandomSymbol());
            }
            return output.ToArray();
        }

        async void SpinReels()
        {
            for(int i = 0; i < rReels.Length; i++)
            {
                await Task.Delay(reel_spin_delay_ms);
                rReels[i].StartReel();
            }
        }

        IEnumerator SpinEnd()
        {
            Debug.Log("ReelSymbols.Count = " + ReelSymbols.Count);
            for (int i = 0; i < rReels.Length; i++)
            {
                rReels[i].StopReel();//Only use for specific reel stop features
            }
            yield return 0;
        }

        List<Symbols[]> GenerateEndReelsSymbols()
        {
            List<Symbols[]> ReturnValue = new List<Symbols[]>(rReels.Length);
            for (int i = 0; i < ReturnValue.Count; i++)
            {
                ReturnValue[i] = new Symbols[rReels[i].transform.childCount];
                Symbols[] temp = ReturnValue[i];
                for (int j = 0; j < ReturnValue[i].Length; j++)
                {
                    temp[j] = (Symbols)UnityEngine.Random.Range(1, (int)Symbols.End); // TODO refactor to use range from supported symbol set
                }
                ReturnValue[i] = temp;
            }
            return ReturnValue;
        }

        //Symbols[] GenerateEndReelSymbolsRandom()
        //{
        //    Symbols[] ReturnValue = new Symbols[iSlotsPerReel];
        //    for (int i = 0; i < ReturnValue.Length; i++)
        //    {
        //        ReturnValue[i] = (Symbols)UnityEngine.Random.Range(1, (int)Symbols.End);
        //    }
        //    return ReturnValue;
        //}

        public void SetMatrixCurrentSpin(Reel[] rReelConfiguration)
        {

        }

        public void SetMatrixNumberOfSpins(List<Reel[]> rReelConfiguration)
        {

        }

        public void PopMultiSpinConfiguration()
        {

        }
        /// <summary>
        /// This will animate the Payline. (May need to cache slots into Event and fire event off. Find out in Optimization Phase)
        /// </summary>
        /// <param name="iPayline"> Defines the Payline. Length of input should be reel length</param>
        public void AnimatePayLine(int[] iPayline)
        {
            for (int i = 0; i < iPayline.Length; i++)
            {
                rReels[i].slots_in_reel[iPayline[i]].PlayAnimation();
            }
        }

        internal void UpdatePositionReels()
        {
            //TODO Fill out reel position logic
            //for (int i = 0; i < rReels.Length; i++)
            //    rReels[i].transform.position = GeneratePosition(i);
        }

        internal void EndSpin()
        {
            for (int i = 0; i < rReels.Length; i++)
            {
                rReels[i].StopReel(endingSymbols[i]);
            }
        }

        internal void UpdateSlotsInReels()
        {
            for (int i = 0; i < rReels.Length; i++)
            {
                rReels[i].UpdateSlotsInReel(matrix[i],this);
            }
        }

        internal void SetReelStripsEndConfiguration()
        {
            for (int i = 0; i < rReels.Length; i++)
            {
                rReels[i].SetEndingDisplaySymbolsTo(endingSymbols[i]);
            }
        }

        internal void TestDisplayPresentationSymbols()
        {
            for (int i = 0; i < rReels.Length; i++)
            {
                rReels[i].TestDisplayEndSymbols();
            }
        }

        internal void DisplayEndingReelStrips()
        {
            for (int i = 0; i < rReels.Length; i++)
            {
                rReels[i].TestDisplayEndSymbols();
            }
        }
    }
}

[System.Serializable]
public class ReelStrip
{
    public int[] display_symbols;
    public ReelStrip(int[] vs)
    {
        display_symbols = vs;
    }
}

[Serializable]
public class SerializableDictionary<TKey, TValue> : Dictionary<TKey, TValue>, ISerializationCallbackReceiver
{
    [SerializeField]
    private List<TKey> keys = new List<TKey>();

    [SerializeField]
    private List<TValue> values = new List<TValue>();

    // save the dictionary to lists
    public void OnBeforeSerialize()
    {
        keys.Clear();
        values.Clear();
        foreach (KeyValuePair<TKey, TValue> pair in this)
        {
            keys.Add(pair.Key);
            values.Add(pair.Value);
        }
    }

    // load dictionary from lists
    public void OnAfterDeserialize()
    {
        this.Clear();

        if (keys.Count != values.Count)
            throw new System.Exception(string.Format("there are {0} keys and {1} values after deserialization. Make sure that both key and value types are serializable."));

        for (int i = 0; i < keys.Count; i++)
            this.Add(keys[i], values[i]);
    }
}
[System.Serializable]
public class Payline
{
    public int[] payline;

    public Payline(int[] vs)
    {
        payline = vs;
    }
}