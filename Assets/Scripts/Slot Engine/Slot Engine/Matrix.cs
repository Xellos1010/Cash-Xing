//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Matrix.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Slot_Engine.Matrix
{

#if UNITY_EDITOR
    [CustomEditor(typeof(Matrix))]
    class MatrixEditor : Editor
    {
        Matrix myTarget;
        SerializedProperty state;
        public void OnEnable()
        {
            myTarget = (Matrix)target;
        }

        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            if (GUILayout.Button("Generate Reels"))
            {
                //myTarget.GenerateMatrix();
            }
            if (GUILayout.Button("Set Reel Positions"))
            {
                myTarget.UpdatePositionReels();
            }
            EditorGUILayout.EnumPopup(StateManager.enCurrentState);
            if (Application.isPlaying)
            {
                if (StateManager.enCurrentState != States.BaseGameSpinLoop && StateManager.enCurrentState != States.BaseGameSpinStart)
                    if (GUILayout.Button("Start Test Spin"))
                    {
                        myTarget.SpinTest();
                        SceneView.RepaintAll();
                    }
                if (StateManager.enCurrentState == States.BaseGameSpinLoop)
                {
                    if (GUILayout.Button("End Test Spin"))
                    {
                        myTarget.SpinTest();
                    }
                }
            }
        }
    }
#endif

    public class Matrix : MonoBehaviour
    {
        public SpinManager spin_manager;
        public Vector3[] matrix; //elements are reels value is slot per reel
        public Vector3 slot_size;
        public Vector3 padding;
        public float spin_speed;
        public int reel_spin_delay_ms = 0;
        public Vector2 reel_slot_padding = new Vector2(1,1); // 1 on each side - top bottom left rigth but shouldn't be 0
        public Reel[] rReels;
        protected List<Symbols[]> _ReelSymbols;

        private List<Symbols[]> ReelSymbols
        {
            get
            {
                if (_ReelSymbols == null)
                    _ReelSymbols = GenerateEndReelsSymbols();
                if (_ReelSymbols.Count == 0)
                    _ReelSymbols = GenerateEndReelsSymbols();
                return _ReelSymbols;
            }
            set
            {
                _ReelSymbols = value;
            }
        }
        //****Unity Default Functions


        //***********
        //TODO - Enable offset from 0,0,0
        public Task GenerateMatrix(Vector3[] matrix, Vector3 slot_size, Vector3 padding)
        {
            this.matrix = matrix;
            this.spin_speed = 80; //TODO change hardcoded reference
            this.slot_size = slot_size;
            this.padding = padding;
            if (transform.childCount > 0) // Destroy old matrix if you have one
            {
                for (int i = transform.childCount - 1; i >= 0; i--)
                    DestroyImmediate(transform.GetChild(i).gameObject);
            }
            rReels = new Reel[matrix.Length]; // Generates the reel 
            for (int i = 0; i < rReels.Length; i++)
            {
                //TODO refactor to call class and auto create object in class
                rReels[i] = GenerateReel(i);
                rReels[i].GenerateSlots(matrix[i], this);
            }
            return Task.CompletedTask;
        }

        Reel GenerateReel(int reel_number)
        {
            //Create Reel Game Object
            Type[] ReelType = new Type[1];
            ReelType[0] = typeof(Reel);
            //Debug.Log("Creating Reel Number " + ReelNumber);
            Reel ReturnValue = new GameObject("Reel_" + reel_number, ReelType).GetComponent<Reel>();
            //Debug.Log("Setting Transform and Parent Reel-" + ReelNumber);
            //Position object in Game Space based on Reel Number Then set the parent
            ReturnValue.transform.parent = transform;
            ReturnValue.reel_number = reel_number;
            return ReturnValue;
        }

        public void SpinTest()
        {
            //TODO refactor implement async
            StopAllCoroutines();
            if (StateManager.enCurrentState != States.BaseGameSpinStart)
                SpinReelsTest();
        }

        async void SpinReelsTest()
        {
            //if(StateManager.state
            StateManager.SwitchState(States.BaseGameSpinStart);
            foreach (Reel rReel in rReels)
            {
                await Task.Delay(reel_spin_delay_ms); //TODO 
            }
            for (int i = 0; i < rReels.Length; i++)
            {
                rReels[i].SpinReel();
                //TODO Set ending reel symbols for testing purposes
                //rReels[i].SetSlotEndConfiguration(GenerateEndReelSymbols());
            }
        }

        IEnumerator SpinEnd()
        {
            StateManager.SwitchState(States.BaseGameSpinEnd);
            Debug.Log("ReelSymbols.Count = " + ReelSymbols.Count);
            for (int i = 0; i < rReels.Length; i++)
            {
                rReels[i].StopReel();//Only use for specific reel stop features
            }
            yield return 0;
        }


        List<Symbols[]> GenerateEndReelsSymbols()
        {
            List<Symbols[]> ReturnValue = new List<Symbols[]>(rReels.Length);
            for (int i = 0; i < ReturnValue.Count; i++)
            {
                ReturnValue[i] = new Symbols[rReels[i].transform.childCount];
                Symbols[] temp = ReturnValue[i];
                for (int j = 0; j < ReturnValue[i].Length; j++)
                {
                    temp[j] = (Symbols)UnityEngine.Random.Range(1, (int)Symbols.End);
                }
                ReturnValue[i] = temp;
            }
            return ReturnValue;
        }

        //Symbols[] GenerateEndReelSymbolsRandom()
        //{
        //    Symbols[] ReturnValue = new Symbols[iSlotsPerReel];
        //    for (int i = 0; i < ReturnValue.Length; i++)
        //    {
        //        ReturnValue[i] = (Symbols)UnityEngine.Random.Range(1, (int)Symbols.End);
        //    }
        //    return ReturnValue;
        //}

        public void SetMatrixCurrentSpin(Reel[] rReelConfiguration)
        {

        }

        public void SetMatrixNumberOfSpins(List<Reel[]> rReelConfiguration)
        {

        }

        public void PopMultiSpinConfiguration()
        {

        }
        /// <summary>
        /// This will animate the Payline. (May need to cache slots into Event and fire event off. Find out in Optimization Phase)
        /// </summary>
        /// <param name="iPayline"> Defines the Payline. Length of input should be reel length</param>
        public void AnimatePayLine(int[] iPayline)
        {
            for (int i = 0; i < iPayline.Length; i++)
            {
                rReels[i].slots_in_reel[iPayline[i]].PlayAnimation();
            }
        }

        internal void UpdatePositionReels()
        {
            //TODO Fill out reel position logic
            //for (int i = 0; i < rReels.Length; i++)
            //    rReels[i].transform.position = GeneratePosition(i);
        }
    }


}