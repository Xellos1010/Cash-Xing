//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : Matrix.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace Slot_Engine.Matrix
{

#if UNITY_EDITOR
    [CustomEditor(typeof(Matrix))]
    class MatrixEditor : Editor
    {
        Matrix myTarget;
        SerializedProperty state;
        SerializedProperty reel_spin_delay_ms;
        public void OnEnable()
        {
            myTarget = (Matrix)target;
            reel_spin_delay_ms = serializedObject.FindProperty("reel_spin_delay_ms");
        }

        public override void OnInspectorGUI()
        {
            base.OnInspectorGUI();
            EditorGUILayout.EnumPopup(StateManager.enCurrentState);
            EditorGUI.BeginChangeCheck();
            reel_spin_delay_ms.intValue = EditorGUILayout.IntSlider("Delay between reels star spin ms",reel_spin_delay_ms.intValue,0,2000);
            if (EditorGUI.EndChangeCheck())
            {
                serializedObject.ApplyModifiedProperties();
            }
            if (Application.isPlaying)
            {
                if (StateManager.enCurrentState != States.BaseGameSpinLoop)
                {
                    if (GUILayout.Button("Start Test Spin"))
                    {
                        myTarget.SpinTest();
                    }
                }
                else
                {
                    if (GUILayout.Button("End Test Spin"))
                    {
                        myTarget.EndSpin();
                    }
                }
            }
        }
    }
#endif

    public class Matrix : MonoBehaviour
    {
        public SpinManager spin_manager;
        public Vector3[] matrix; //elements are reels value is slot per reel
        public Vector3 slot_size;
        public Vector3 padding;
        public float spin_speed;
        public int reel_spin_delay_ms = 0;
        public Vector2 reel_slot_padding = new Vector2(0,1); //TODO set from Matrix Generator
        public Reel[] rReels;
        protected List<Symbols[]> _ReelSymbols;

        private List<Symbols[]> ReelSymbols
        {
            get
            {
                if (_ReelSymbols == null)
                    _ReelSymbols = GenerateEndReelsSymbols();
                if (_ReelSymbols.Count == 0)
                    _ReelSymbols = GenerateEndReelsSymbols();
                return _ReelSymbols;
            }
            set
            {
                _ReelSymbols = value;
            }
        }
        //****Unity Default Functions


        //***********
        //TODO - Enable offset from 0,0,0
        public Task GenerateMatrix(Vector3[] matrix, Vector3 slot_size, Vector3 padding)
        {
            this.matrix = matrix;
            this.spin_speed = 80; //TODO change hardcoded reference
            this.slot_size = slot_size;
            this.padding = padding;
            if (transform.childCount > 0) // Destroy old matrix if you have one
            {
                for (int i = transform.childCount - 1; i >= 0; i--)
                    DestroyImmediate(transform.GetChild(i).gameObject);
            }
            GenerateReels(matrix);
            return Task.CompletedTask;
        }

        private void GenerateReels(Vector3[] matrix)
        {
            List<Reel> newReelList = new List<Reel>();
            if (rReels == null)
                rReels = new Reel[0];
            newReelList.AddRange(rReels);
            if(newReelList.Count < matrix.Length)
            {
                for (int i = 0; i < matrix.Length; i++)
                {
                    if(i == newReelList.Count)
                    {
                        newReelList.Add(GenerateReel(i));
                    }
                    newReelList[i].UpdateSlotsInReel(matrix[i], this);
                }
            }
            rReels = newReelList.ToArray();
        }

        Reel GenerateReel(int reel_number)
        {
            //Create Reel Game Object
            Type[] ReelType = new Type[1];
            ReelType[0] = typeof(Reel);
            //Debug.Log("Creating Reel Number " + ReelNumber);
            Reel ReturnValue = new GameObject("Reel_" + reel_number, ReelType).GetComponent<Reel>();
            //Debug.Log("Setting Transform and Parent Reel-" + ReelNumber);
            //Position object in Game Space based on Reel Number Then set the parent
            ReturnValue.transform.parent = transform;
            ReturnValue.reel_number = reel_number;
            return ReturnValue;
        }

        public void SpinTest()
        {
            //TODO refactor implement async and stop all tasks
            StopAllCoroutines();
            if (StateManager.enCurrentState != States.BaseGameSpinStart)
                SpinReels();
        }

        async void SpinReels()
        {
            //if(StateManager.state
            StateManager.SwitchState(States.BaseGameSpinStart);
            for(int i = 0; i < rReels.Length; i++)
            {
                await Task.Delay(reel_spin_delay_ms);
                rReels[i].SpinReel();
            }
            StateManager.SwitchState(States.BaseGameSpinLoop);
        }

        IEnumerator SpinEnd()
        {
            StateManager.SwitchState(States.BaseGameSpinEnd);
            Debug.Log("ReelSymbols.Count = " + ReelSymbols.Count);
            for (int i = 0; i < rReels.Length; i++)
            {
                rReels[i].StopReel();//Only use for specific reel stop features
            }
            yield return 0;
        }

        List<Symbols[]> GenerateEndReelsSymbols()
        {
            List<Symbols[]> ReturnValue = new List<Symbols[]>(rReels.Length);
            for (int i = 0; i < ReturnValue.Count; i++)
            {
                ReturnValue[i] = new Symbols[rReels[i].transform.childCount];
                Symbols[] temp = ReturnValue[i];
                for (int j = 0; j < ReturnValue[i].Length; j++)
                {
                    temp[j] = (Symbols)UnityEngine.Random.Range(1, (int)Symbols.End); // TODO refactor to use range from supported symbol set
                }
                ReturnValue[i] = temp;
            }
            return ReturnValue;
        }

        //Symbols[] GenerateEndReelSymbolsRandom()
        //{
        //    Symbols[] ReturnValue = new Symbols[iSlotsPerReel];
        //    for (int i = 0; i < ReturnValue.Length; i++)
        //    {
        //        ReturnValue[i] = (Symbols)UnityEngine.Random.Range(1, (int)Symbols.End);
        //    }
        //    return ReturnValue;
        //}

        public void SetMatrixCurrentSpin(Reel[] rReelConfiguration)
        {

        }

        public void SetMatrixNumberOfSpins(List<Reel[]> rReelConfiguration)
        {

        }

        public void PopMultiSpinConfiguration()
        {

        }
        /// <summary>
        /// This will animate the Payline. (May need to cache slots into Event and fire event off. Find out in Optimization Phase)
        /// </summary>
        /// <param name="iPayline"> Defines the Payline. Length of input should be reel length</param>
        public void AnimatePayLine(int[] iPayline)
        {
            for (int i = 0; i < iPayline.Length; i++)
            {
                rReels[i].slots_in_reel[iPayline[i]].PlayAnimation();
            }
        }

        internal void UpdatePositionReels()
        {
            //TODO Fill out reel position logic
            //for (int i = 0; i < rReels.Length; i++)
            //    rReels[i].transform.position = GeneratePosition(i);
        }

        internal void EndSpin()
        {
            //TODO refactor to calculate distance till reels present final symbol configuration
            StateManager.SwitchState(States.BaseGameSpinEnd);
            for (int i = 0; i < rReels.Length; i++)
            {
                rReels[i].StopReel();
            }
            StateManager.SwitchState(States.BaseGameIdle);
        }

        internal void UpdateSlotsInReels()
        {
            for (int i = 0; i < rReels.Length; i++)
            {
                rReels[i].UpdateSlotsInReel(matrix[i],this);
            }
        }
    }


}