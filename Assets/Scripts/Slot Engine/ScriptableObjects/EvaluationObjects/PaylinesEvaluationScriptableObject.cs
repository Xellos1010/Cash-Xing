//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : SlotEngine.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
using BoomSports.Prototype.Managers;
using System.Collections.Generic;
using System;

namespace BoomSports.Prototype.ScriptableObjects
{
    public enum paylineDirection
    {
        left,
        right,
        both,
        customcolumns,
        count
    }
    [Serializable]
    public class CustomColumns
    {
        /// <summary>
        /// Columns of the root nodes to process
        /// </summary>
        [SerializeField]
        public int rootColumn;
        /// <summary>
        /// Evaluate nodes in this column adjacent left right only
        /// </summary>
        [SerializeField]
        public bool evaluateAdjacentRightLeftOnly;
        /// <summary>
        /// Whether you evaluate left or right - abstract to support different directions
        /// </summary>
        [SerializeField]
        public bool leftRight;
    }
    /// <summary>
    /// Paylines Evaluation Scriptable Object - Holds nodes and conditions to build nodes and store information
    /// </summary>
    [CreateAssetMenu(fileName = "PaylinesEvaluationObject", menuName = "BoomSportsScriptableObjects/PaylinesEvaluationScriptableObject", order = 4)]
    public class PaylinesEvaluationScriptableObject : BaseEvaluationScriptableObject
    {
        /// <summary>
        /// Which way should the evaluation take place?
        /// </summary>
        public paylineDirection evaluationDirection;
        /// <summary>
        /// number of paylines supported - pre-generated in editor mode
        /// </summary>
        public int number_of_paylines = 0;
        /// <summary>
        /// Should not exceed column count of spin Strips
        /// </summary>
        public CustomColumns[] customColumnsDefine;
        /// <summary>
        /// The root nodes for dynamic paylines using a suffix tree
        /// </summary>
        public SuffixTreeRootNodes dynamic_paylines;
        public EvaluationObjectStruct evaluationUsed;
        /// <summary>
        /// MainEntry to evaluate for WinningPaylines
        /// </summary>
        /// <param name="evaluationObject">The Configuration & Feature slot evaluators</param>
        /// <returns>WinningPayline[]</returns>
        public override object EvaluatePaylines(ref EvaluationObjectStruct evaluationObject)
        {
            evaluationUsed = evaluationObject;
            List<WinningPayline> outputRaw = new List<WinningPayline>();
            List<WinningPayline> outputFiltered = new List<WinningPayline>();
            //Debug.Log($"dynamic_paylines.rootNodes.Length = {dynamic_paylines.paylineNodes.Length}");

            //Evaluate each root node and check active feature conditions
            for (int rootNode = 0; rootNode < dynamic_paylines.paylineNodes.Length; rootNode++)
            {
                //Debug.Log($"Evaluating Root Node {dynamic_paylines.paylineNodes[rootNode].nodeInfo.Print()} before evaluation outputRaw.Count = {outputRaw.Count} outputFiltered.Count = {outputFiltered.Count}");
                //Add initial winning lines
                outputRaw.AddRange(dynamic_paylines.paylineNodes[rootNode].EvaluateRawWinningPaylines(ref evaluationObject));
                //Debug.Log($"Root Node {dynamic_paylines.paylineNodes[rootNode].nodeInfo.Print()} before payline consolidation= {outputRaw.Count} outputFiltered.Count = {outputFiltered.Count}");
                //for (int i = 0; i < outputRaw.Count; i++)
                //{
                //    //Debug.Log$"Raw winning payline {i} = {outputRaw[i].PrintWinningNodesAndSymbols()}");
                //}

                //Filter for duplicate linewins and merge lists
                if(outputRaw.Count > 0)
                    ConsolidateWinningPaylines(ref outputFiltered, ref outputRaw);
                //Debug.Log($"Root Node {dynamic_paylines.paylineNodes[rootNode].nodeInfo.Print()} after filter outputRaw.Count = {outputRaw.Count} outputFiltered.Count = {outputFiltered.Count}");
                outputRaw.Clear();
            }

            //Since we evaluated all nodes and added a list of raw nodes that have features we will parse thru and see which onces actually activate and apply

            //For now we will have features activate on a case by case basis until we can figure out a generic way to associate features and associate actions
            //TODO Add each feature that triggers featureEvaluationActiveCount when adding winning symbol
            if (evaluationObject.featureEvaluationActiveCount != null)
            {
                //Iterate over each key - find paired evaluator - run conditionals on evaluator
                //Debug.Log(String.Format("Looking for features that activated"));
                foreach (KeyValuePair<Features, List<SuffixTreeNodeInfo>> item in evaluationObject.featureEvaluationActiveCount)
                {
                    //Iterate thru evaluators and check conditions
                    for (int evaluator = 0; evaluator < evaluationObject.slotEvaluationObjects.Length; evaluator++)
                    {
                        if(evaluationObject.slotEvaluationObjects[evaluator].featureName == item.Key)
                        {
                            //Run conditional check on every slot and add to winning node list in evaluator
                            for (int node = 0; node < item.Value.Count; node++)
                            {
                                if(evaluationObject.slotEvaluationObjects[evaluator].EvaluateNodeForConditionsMet(item.Value[node], outputFiltered.ToArray()))
                                {
                                    //Debug.Log($"Node {item.Value[node].Print()} activated feature {item.Key.ToString()} ");
                                    evaluationObject.slotEvaluationObjects[evaluator].AddRawNodeActivatingFeature(item.Value[node]);
                                }
                            }
                            //if (evaluationObject.slotEvaluationObjects[evaluator].nodesActivatingEvaluationConditions.Count > 0)
                            //{
                            //    //Debug.Log($"Feature {item.Key} activated on nodes {evaluationObject.slotEvaluationObjects[evaluator].PrintActivatingNodes()}");
                            //    //Activate any nodes that met conditional requirements
                            //    evaluationObject.slotEvaluationObjects[evaluator].ActivateWinningNodesEvents();
                            //}
                        }
                    }
                    //Multiplier calculated first then mode is applied
                    //Debug.Log(String.Format("Feature name = {0}, counter = {1} mode - {2}", item.Key.ToString(), item.Value.Count, StateManager.enCurrentMode));
                    //if ((item.Key == Features.overlay || item.Key == Features.multiplier))
                    //{
                    //    TriggerFeatureEvaluationScriptableObject overlayLogic = EvaluationManager.GetFirstInstanceFeatureEvaluationObject<TriggerFeatureEvaluationScriptableObject>(ref evaluationObject.slotEvaluationObjects);
                    //    //Feature Evaluated Slot items are in raw format waiting for winningObjects to be generated to run evaluation logic- run check if items are valid
                    //    for (int node = item.Value.Count - 1; node >= 0; node--)
                    //    {
                    //        if (!overlayLogic.EvaluateNodeForConditionsMet(item.Value[node], outputFiltered.ToArray()))
                    //        {
                    //            item.Value.RemoveAt(node);
                    //        }
                    //    }
                    //    if (item.Value.Count > 0)
                    //    {
                    //        if (StaticStateManager.enCurrentMode != GameModes.freeSpin)
                    //        {
                    //            if (StaticStateManager.enCurrentMode == GameModes.baseGame) //Can Only apply overlay feature in base-game
                    //                StaticStateManager.SetFeatureActiveTo(Features.multiplier, true);
                    //            EvaluationManager.GetFirstInstanceFeatureEvaluationObject<TriggerFeatureEvaluationScriptableObject>(ref evaluationObject.slotEvaluationObjects).nodesActivatingEvaluationConditions = item.Value;
                    //        }
                    //        else
                    //        {
                    //            StaticStateManager.AddToMultiplier(item.Value.Count);
                    //        }
                    //    }
                    //}
                    //if (item.Key == Features.freespin)
                    //{
                    //    FreeSpinEvaluationScriptableObject freespinsObject = EvaluationManager.GetFirstInstanceFeatureEvaluationObject<FreeSpinEvaluationScriptableObject>(ref evaluationObject.slotEvaluationObjects);
                    //    bool activateFeature = freespinsObject.EvaluateConditionsMet(item.Value, outputFiltered.ToArray());
                    //    if (activateFeature)
                    //    {
                    //        StaticStateManager.SetFeatureActiveTo(Features.freespin, true);
                    //    }
                    //    else
                    //    {
                    //        freespinsObject.nodesActivatingEvaluationConditions.Clear();
                    //        break;
                    //    }
                    //}
                }
            }
            evaluated = true;
            if (winningObjects == null)
                winningObjects = new List<WinningObject>();
            winningObjects.AddRange(outputFiltered.ToArray());
            BuildWinningSymbolNodes(ref winningObjects); 
            return outputFiltered.ToArray();
        }

        private void BuildWinningSymbolNodes(ref List<WinningObject> winningPaylines)
        {
            HashSet<WinningEvaluatedNodeContainer> winningNodes = new HashSet<WinningEvaluatedNodeContainer>();
            for (int payline = 0; payline < winningPaylines.Count; payline++)
            {
                for (int node = 0; node < winningPaylines[payline].winningNodes.Length; node++)
                {
                    winningNodes.Add(winningPaylines[payline].winningNodes[node]);
                }
            }
            if (evaluationUsed.winningEvaluationNodes == null)
                evaluationUsed.winningEvaluationNodes = new List<WinningEvaluatedNodeContainer>();
            evaluationUsed.winningEvaluationNodes.AddRange(winningNodes);
        }

        public override int? ReturnEvaluationObjectSupportedRootCount()
        {
            return number_of_paylines;
        }

        //Generating Paylines supported froma matrix
        internal void GenerateDynamicPaylinesFromConfigurationObjectsGroupManagers(ref ConfigurationDisplayZonesStruct[] displayZones)
        {
            //        Initialize:
            //          Create a root node at column 0(off - screen, non - column part of all solutions)
            //          root node.length = 0
            //          root node.terminal = false
            //          Add all paylines(in the form of length w arrays of integers ranging from 1 to h) to the root nodes' "toDistribute set"
            //          Create a toWork queue, add the root node to it

            //        Iterate: while toWork not empty:
            //          let node n = toWork.pop()
            //          if n.length < w
            //          create children of n with length n.length + 1 and terminal = (n.length + 1 == w).
            //          for payline p in n.toDistribute
            //          remove p from n.toDistribute
            //          if (p.length > 1)
            //              add p.subArray(1, end) to child of n as applicable.
            //              add children of n to toWork
            //Node 0 is connected to 0 / 1
            //Initializing the first reel root nodes
            List<SuffixTreeNode> paylines = new List<SuffixTreeNode>();
            List<SuffixTreeNode> finished_list = new List<SuffixTreeNode>();

            number_of_paylines = 0;
            dynamic_paylines.paylinesSupported = new List<Payline>();

            dynamic_paylines.paylineNodes = InitializeRootNodes(ref displayZones).ToArray();
            List<SuffixTreeNode> to_finish_list = new List<SuffixTreeNode>();

            for (int root_node = 0; root_node < dynamic_paylines.paylineNodes.Length; root_node++)
            {
                //Start a new payline that is going to be printed per root node
                List<int> payline = new List<int>();
                //Build all paylines
                BuildPayline(ref payline, ref dynamic_paylines.paylineNodes[root_node], ref displayZones, evaluationDirection, ref dynamic_paylines.paylineNodes[root_node], customColumnsDefine);
            }
        }
        internal void BuildPayline(ref List<int> payline, ref SuffixTreeNode currentPaylineNode, ref ConfigurationDisplayZonesStruct[] displayZones, paylineDirection evaluationDirection, ref SuffixTreeNode rootNode, CustomColumns[] customColumnsDefine = null)
        {
            //Debug.Log($"Payline before nodeInfo registered = {String.Join("|", payline)}");
            //Add current node to payline
            payline.Add(currentPaylineNode.nodeInfo.row);
            //Debug.Log($"Payline after nodeInfo registered = {String.Join("|", payline)}");
            int next_column = currentPaylineNode.leftRight ? currentPaylineNode.nodeInfo.column + 1 : currentPaylineNode.nodeInfo.column - 1;
            //Debug.Log($"next_column from {currentPaylineNode.nodeInfo.Print()} {next_column } = {currentPaylineNode.leftRight} node.left_right ? node.node_info.column + 1 : node.node_info.column - 1;");
            //Check the column is the last column and continue if it is
            if (currentPaylineNode.leftRight ?
                next_column >= displayZones.Length :
                next_column < 0)
            {
                //Debug.Log("Reached end of payline");
                dynamic_paylines.AddPaylineSupported(payline.ToArray(), currentPaylineNode.leftRight, rootNode);
                number_of_paylines += 1;
            }
            else
            {
                SuffixTreeNode parentNode = currentPaylineNode;
                ConfigurationDisplayZonesStruct displayZoneNextColumn = displayZones[next_column];
                //Next Node needs to initialize ndes further down the tree
                currentPaylineNode.InitializeConnectedNodes(next_column, ref displayZoneNextColumn, ref parentNode, currentPaylineNode.leftRight,evaluationDirection, customColumnsDefine);
                for (int child_nodes = 0; child_nodes < currentPaylineNode.connectedNodes.Length; child_nodes++)
                {
                    //Now build out the child refs
                    BuildPayline(ref payline, ref currentPaylineNode.connectedNodes[child_nodes], ref displayZones, evaluationDirection,ref rootNode, customColumnsDefine);
                    //Remove payline buildup
                    payline.RemoveRange(currentPaylineNode.parentNodes.Length, payline.Count - currentPaylineNode.parentNodes.Length);
                }
            }
        }

        private List<SuffixTreeNode> InitializeRootNodes(ref ConfigurationDisplayZonesStruct[] displayZones)
        {
            List<SuffixTreeNode> root_nodes = new List<SuffixTreeNode>();
            SuffixTreeNode node;
            //Initialize all the rows and the next elements
            switch (evaluationDirection)
            {
                case paylineDirection.left:
                    root_nodes.AddRange(BuildRootNodes(0, displayZones[0], true));
                    break;
                case paylineDirection.right:
                    root_nodes.AddRange(BuildRootNodes(displayZones.Length - 1, displayZones[displayZones.Length - 1], false));
                    break;
                case paylineDirection.both:
                    root_nodes.AddRange(BuildRootNodes(0, displayZones[0], true));
                    root_nodes.AddRange(BuildRootNodes(displayZones.Length - 1, displayZones[displayZones.Length - 1], false));
                    break;
                case paylineDirection.customcolumns:
                    for (int column = 0; column < customColumnsDefine.Length; column++)
                    {
                        //Debug.Log($"Building Custom Column {column} customColumnsDefine[column].rootColumn = {customColumnsDefine[column].rootColumn}");
                        root_nodes.AddRange(BuildRootNodes(customColumnsDefine[column].rootColumn, displayZones[customColumnsDefine[column].rootColumn], customColumnsDefine[column].leftRight));
                        //Debug.Log($"root_nodes count = {root_nodes.Count}");
                    }
                    break;
                default:
                    //Debug.Log("Please set the evaluation direciton to left, right or both");
                    break;
            }
            return root_nodes;
        }
        /// <summary>
        /// Each active payline zone is a root node for evaluation
        /// </summary>
        /// <param name="column"></param>
        /// <param name="configurationDisplayZonesStruct"></param>
        /// <param name="left_right"></param>
        /// <returns></returns>
        private List<SuffixTreeNode> BuildRootNodes(int column, ConfigurationDisplayZonesStruct configurationDisplayZonesStruct, bool left_right)
        {
            List<SuffixTreeNode> root_nodes = new List<SuffixTreeNode>();
            SuffixTreeNode node;
            DisplayZoneStruct displayZone;
            //Row is automatically the first available node non padding node
            int row = configurationDisplayZonesStruct.paddingBefore;
            int totalPositions = 0;
            //Loop through each display zone and build a root node for each active row
            for (int display_zone = 0; display_zone < configurationDisplayZonesStruct.displayZones.Length; display_zone++)
            {
                displayZone = configurationDisplayZonesStruct.displayZones[display_zone];
                totalPositions += configurationDisplayZonesStruct.displayZones[display_zone].positionsInZone;
                if (displayZone.activePaylineEvaluations)
                {
                    for (int slot = 0; slot < displayZone.positionsInZone; slot++)
                    {
                        //Build my node
                        node = new SuffixTreeNode(column, row, null, new SuffixTreeNodeInfo(-1, -1), left_right);
                        root_nodes.Add(node);
                        //Debug.Log(String.Format("Registering Root Node {0}", node.node_info.Print()));
                        row += 1;
                    }
                }
                else
                {
                    // //Debug.LogString.Format("Non-active pay zone- skipping {0} rows ", displayZone.positionsInZone));
                    for (int slot = 0; slot < displayZone.positionsInZone; slot++)
                    {
                        //Register blank slot
                        // //Debug.LogString.Format("Root Node {0} {1} not in active payzone", column, row));
                        row += 1;
                    }
                }
            }
            return root_nodes;
        }

        private static List<int> GenerateConnectedNodes(ref DisplayZoneStruct[] rows_in_next_column, int primary_node)
        {
            List<int> connected_nodes = new List<int>();
            if (IsInActiveDisplayZone(primary_node - 1, ref rows_in_next_column))
            {
                connected_nodes.Add(primary_node - 1);
            }
            //if you have a 5x4x3x4x5 then we want to be able to calculate 5 -> 4 but not 4 -> 5
            if (IsInActiveDisplayZone(primary_node, ref rows_in_next_column))
            {
                connected_nodes.Add(primary_node);
            }
            //if you have a 5x4x3x4x5 then we want to be able to calculate 5 -> 4 but not 4 -> 5
            if (IsInActiveDisplayZone(primary_node + 1, ref rows_in_next_column))
            {
                connected_nodes.Add(primary_node + 1);
            }

            return connected_nodes;
        }
        private static bool IsInActiveDisplayZone(int node, ref DisplayZoneStruct[] display_zones)
        {
            int active_slot = 0;
            for (int i = 0; i < display_zones.Length; i++)
            {
                if (active_slot > node)
                    return false;
                if (display_zones[i].activePaylineEvaluations)
                {
                    for (int slot = 0; slot < display_zones[i].positionsInZone; slot++)
                    {
                        if (node == active_slot)
                        {
                            return true;
                        }
                        active_slot += 1;
                    }
                }
                else
                {
                    active_slot += display_zones[i].positionsInZone;
                }
            }
            return false;
        }
        /// <summary>
        /// Filters out duplicate paylines from raw winning evaluations
        /// </summary>
        /// <param name="winningPaylinesFiltered"></param>
        /// <param name="winningPaylinesRaw"></param>
        /// <param name="maxLength"></param>
        private void ConsolidateWinningPaylines(ref List<WinningPayline> winningPaylinesFiltered, ref List<WinningPayline> winningPaylinesRaw)
        {
            //Debug.Log$"Consolidating Paylines winningPaylinesFiltered.Count = {winningPaylinesFiltered.Count} winningPaylinesRaw.Count = {winningPaylinesRaw.Count}");
            string rawList = "";
            string filteredList = "";
            for (int i = 0; i < winningPaylinesRaw.Count; i++)
            {
                rawList += winningPaylinesRaw[i].PrintWinningNodesAndSymbols() + "\n";
            }
            for (int i = 0; i < winningPaylinesFiltered.Count; i++)
            {
                filteredList += winningPaylinesFiltered[i].PrintWinningNodesAndSymbols() + "\n";
            }
            //Debug.Log$"Printing all raw paylines \n {rawList} ");
            //Debug.Log$"Printing all filtered paylines \n {filteredList} ");
            //Initialize List for duplicate paylines
            List<WinningPayline> duplicatePaylines = new List<WinningPayline>();
            WinningPayline rawPaylineToCheck;
            for (int rawPaylineChecking = winningPaylinesRaw.Count-1; rawPaylineChecking >= 0; rawPaylineChecking--)
            {
                //Set raw payline to check against list of filtered paylines
                rawPaylineToCheck = winningPaylinesRaw[rawPaylineChecking];
                //Debug.Log$"rawPaylineToCheck = winningPaylinesRaw[{rawPaylineChecking}] {rawPaylineToCheck.PrintWinningNodesAndSymbols()}");
                //Check each filtered winning payline
                for (int currentWinningPaylineChecking = winningPaylinesFiltered.Count-1; currentWinningPaylineChecking >= 0; currentWinningPaylineChecking--)
                {
                    //Debug.Log$"Duplicate payline Check \n {rawPaylineToCheck.PrintWinningNodesAndSymbols()}<->{winningPaylinesFiltered[currentWinningPaylineChecking].PrintWinningNodesAndSymbols()}");

                    if(rawPaylineToCheck.winningNodes.Length > winningPaylinesFiltered[currentWinningPaylineChecking].winningNodes.Length)
                    {
                        //Debug.Log$"rawPaylineToCheck.ContainsAllNodes(winningPaylinesFiltered[currentWinningPaylineChecking].winningNodes) = {rawPaylineToCheck.ContainsAllNodes(winningPaylinesFiltered[currentWinningPaylineChecking].winningNodes)}");
                        if(rawPaylineToCheck.ContainsAllNodes(winningPaylinesFiltered[currentWinningPaylineChecking].winningNodes))
                        {
                            //Debug.Log$"rawPaylineToCheck contains all nodes from winningPaylinesFiltered[currentWinningPaylineChecking] - Remove winningPaylinesFiltered[{currentWinningPaylineChecking}]");
                            winningPaylinesFiltered.RemoveAt(currentWinningPaylineChecking);
                        }
                    }
                    else
                    {
                        //Debug.Log$"winningPaylinesFiltered[currentWinningPaylineChecking].ContainsAllNodes(rawPaylineToCheck.winningNodes)) = {winningPaylinesFiltered[currentWinningPaylineChecking].ContainsAllNodes(rawPaylineToCheck.winningNodes)}");

                        if (winningPaylinesFiltered[currentWinningPaylineChecking].ContainsAllNodes(rawPaylineToCheck.winningNodes))
                        {
                            //Debug.Log$"winningPaylinesFiltered[currentWinningPaylineChecking]contains all nodes from rawPaylineToCheck - Remove rawPaylineToCheck[{rawPaylineChecking}]");
                            winningPaylinesRaw.RemoveAt(rawPaylineChecking);
                        }
                    }
                }
            }
            //Add raw paylines to winning paylines
            winningPaylinesFiltered.AddRange(winningPaylinesRaw);
        }


        private int GetPossiblePaylineCombinations(ref SuffixTreeNode suffix_tree_node)
        {
            int paylines_supported = 0;
            if (suffix_tree_node.connectedNodes != null)
            {
                paylines_supported = suffix_tree_node.connectedNodes.Length;
                if (suffix_tree_node.connectedRows.Length > 0)
                {
                    for (int sub_node = 0; sub_node < suffix_tree_node.connectedNodes.Length; sub_node++)
                    {
                        paylines_supported += GetPossiblePaylineCombinations(ref suffix_tree_node.connectedNodes[sub_node]);
                    }
                }
            }
            return paylines_supported;
        }

        public override void ClearWinningObjects()
        {
            winningObjects = new List<WinningObject>();
        }
    }
}