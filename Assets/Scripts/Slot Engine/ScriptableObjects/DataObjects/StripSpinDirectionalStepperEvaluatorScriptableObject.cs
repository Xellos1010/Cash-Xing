//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : SlotEngine.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using UnityEngine;
/// <summary>
/// Creates the scriptable object for a stepper strip - Flow of Stepper Strip
/// On Spin Start: Wait X Seconds - lerp x units (x = slotSize.y + padding.y) (tweening happens here with lerp % complete to -> from position) - repeat
/// On Slam: Check X seconds remaining to step - step if below 1/2 time to step. Needs to be refactored if RMG requirements come into play
/// </summary>
[CreateAssetMenu(fileName = "StripSpinStepperParameters", menuName = "BoomSportsScriptableObjects/StripSpinStepperParametersScriptableObject", order = 2)]
public class StripSpinDirectionalStepperEvaluatorScriptableObject : StripSpinEvaluatorBaseScriptableObject
{
    /// <summary>
    /// Controls the amount of slots to traverse each lerp cycle
    /// </summary>
    [SerializeField]
    public int slotsToTraverse = 1;
    /// <summary>
    /// How many steps per spin is the player allowed?
    /// </summary>
    public int stepsPerSpin = 1;
    /// <summary>
    /// Controls the spin amount during looping state
    /// </summary>
    [SerializeField]
    public float pauseBetweenStepsFor = 0.5f;
    /// <summary>
    /// Controls the spin amount during looping state
    /// </summary>
    [SerializeField]
    public float activeLerpTimeToCompleteStep = 0.6777f;
    /// <summary>
    /// = slot (spinDirection * Slot Width Height + Slot.padding) * slotsToTraverse
    /// </summary>
    public Vector3 amountToTraverseDuringStep;
    public Vector3 amountToSkipDuringPauseStep;
    /// <summary>
    /// Sequence for evaluation - spin timer 0 -> lerpOverTime 
    /// </summary>
    /// <param name="spinTimerCurrent"></param>
    /// <param name="pathPositions"></param>
    /// <returns></returns>
    public override Vector3 EvaluateSpin(float spinTimerCurrent, ref SpinPath pathPositions)
    {
        //Debug.Log("Evaluating Stepper Directional Spin");
        //The amount movement 1 cycle of lerpOverTime evaluates raw
        Vector3 rawDistanceTravelTotalActive = pathPositions.slotSize + pathPositions.slotPadding;
        //The amount of movement to pauses for timeTillStartLerp
        Vector3 rawDistanceTravelTotalInactive = (pathPositions.slotSize + pathPositions.slotPadding) * (float)(pauseBetweenStepsFor / activeLerpTimeToCompleteStep);

        amountToTraverseDuringStep = new Vector3(
            reel_spin_direction.x * rawDistanceTravelTotalActive.x,
            reel_spin_direction.y * rawDistanceTravelTotalActive.y,
            reel_spin_direction.z * rawDistanceTravelTotalActive.z
            );
        
        //Debug.Log($"amountToTraverseDuringStep = {amountToTraverseDuringStep.ToString()}");

        amountToSkipDuringPauseStep = new Vector3(
            reel_spin_direction.x * rawDistanceTravelTotalInactive.x,
            reel_spin_direction.y * rawDistanceTravelTotalInactive.y,
            reel_spin_direction.z * rawDistanceTravelTotalInactive.z
            );

        //Initialize Output with start position
        Vector3 output = pathPositions.path[pathPositions.startPosition];
        //Initialize Steps completed sequence - used to compare whether to change symbol or not
        //Start Poisition index is corelated to Steps completed in path
        int stepsCompletedSoFar = pathPositions.startPosition;
        int stepsToCompletePath = pathPositions.path.Length - 1;

        //Calling object passes previously evaluated Steps that have been compelted - SpinPath will contain the times path has reached end position.
        //If the current spin timer is over a sequence step total then we need to pre-determine based on times reached end where in position 
        //(lerpOverTime + timeTillStartLerp) gets the total time of a sequence * the steps to complete the sequence * stepsToCompletePath + 1 - change symbol if >
        float lerpTimeToCompletePath = ((activeLerpTimeToCompleteStep + pauseBetweenStepsFor) * stepsToCompletePath) * (pathPositions.timesReachedEndOfPath + 1);
        int timesReachedEndOfPath = 0;
        float startTimeOnPath = ((activeLerpTimeToCompleteStep + pauseBetweenStepsFor) * stepsCompletedSoFar);
        //Debug.Log($"Adding initialTimeOnPath {initialTimeOnPath} to spinCurrent {spinTimerCurrent}");
        spinTimerCurrent += startTimeOnPath; //SpinTimer now in realtime

        if (stepsPerSpin < 0)
        {
            //Initial check to see if the spin timer supplied is > Initial end of path
            if (spinTimerCurrent > lerpTimeToCompletePath)
            {
                //Debug.Log($"SpinTimerCurrent {spinTimerCurrent} > end of path {lerpTimeToCompletePath}");
                //Set the path to the start
                //For debug purposes can pass the path x times and evaluate further in sequence - First Increment Steps and Path
                while (spinTimerCurrent > lerpTimeToCompletePath)
                {
                    output = pathPositions.path[0];
                    //Increment times reached end of path for each time end of path is reached
                    timesReachedEndOfPath += 1;
                    stepsCompletedSoFar = 0; //May be used later
                                             //Make initial time on path the completed path time now
                    startTimeOnPath = lerpTimeToCompletePath;
                    lerpTimeToCompletePath += ((activeLerpTimeToCompleteStep + pauseBetweenStepsFor) * stepsToCompletePath);
                    //Debug.Log($" lerpTimeToCompletePath updated to {lerpTimeToCompletePath}");
                }
            }
            //Debug.Log($"Now entering current sequence output = {output}");
            while (startTimeOnPath < spinTimerCurrent)
            {
                //Debug.Log($"{initialTimeOnPath} < {spinTimerCurrent}"); 
                //first step from 0 - lerpOverTime
                if (spinTimerCurrent > startTimeOnPath + activeLerpTimeToCompleteStep)
                {
                    //Debug.Log($"amountToTraverseDuringStep {amountToTraverseDuringStep.ToString()} being added to output {output.ToString()}");
                    startTimeOnPath += activeLerpTimeToCompleteStep;
                    //If you are in a pause period only moving to the next position;
                    output += amountToTraverseDuringStep;
                    if (spinTimerCurrent > startTimeOnPath + pauseBetweenStepsFor)
                    {
                        //Debug.Log($"We are in next step - add pause time to lerpTime. {initialTimeOnPath} += {timeTillStartLerp}");
                        startTimeOnPath += pauseBetweenStepsFor;
                    }
                    else
                    {
                        //Debug.Log($"We are setting final position step - add pause time to lerpTime. {initialTimeOnPath} += {timeTillStartLerp}");
                        startTimeOnPath += spinTimerCurrent - startTimeOnPath;
                    }
                }
                else
                {
                    //Debug.Log($"Adding amountToTraverseDuringStep {amountToTraverseDuringStep} * ((float)(spinTimerCurrent{spinTimerCurrent}/lerpOverTime{lerpOverTime})){(spinTimerCurrent / lerpOverTime)} = {amountToTraverseDuringStep * (spinTimerCurrent / lerpOverTime)} being added to output {output.ToString()}");
                    output += amountToTraverseDuringStep * ((spinTimerCurrent - startTimeOnPath) / activeLerpTimeToCompleteStep);
                    startTimeOnPath += spinTimerCurrent - startTimeOnPath;
                }
            }
        }
        else
        {
            //calculate amount of time to complete step and return that positions step
            //1 step will have an additional pause period
            float timeToCompletePath = startTimeOnPath + ((activeLerpTimeToCompleteStep + pauseBetweenStepsFor) * stepsPerSpin);
            if (spinTimerCurrent < timeToCompletePath) //See which part of stepper sequence are you in - solve for 1 first them many
            {
                while (startTimeOnPath < spinTimerCurrent)
                {
                    //Debug.Log($"{initialTimeOnPath} < {spinTimerCurrent}"); 
                    //first step from 0 - lerpOverTime
                    if (spinTimerCurrent > startTimeOnPath + activeLerpTimeToCompleteStep)
                    {
                        //Debug.Log($"amountToTraverseDuringStep {amountToTraverseDuringStep.ToString()} being added to output {output.ToString()}");
                        startTimeOnPath += activeLerpTimeToCompleteStep;
                        //If you are in a pause period only moving to the next position;
                        output += amountToTraverseDuringStep;
                        if (spinTimerCurrent > startTimeOnPath + pauseBetweenStepsFor)
                        {
                            //Debug.Log($"We are in next step - add pause time to lerpTime. {initialTimeOnPath} += {timeTillStartLerp}");
                            startTimeOnPath += pauseBetweenStepsFor;
                            stepsCompletedSoFar += 1;
                        }
                        else
                        {
                            //Debug.Log($"We are setting final position step - add pause time to lerpTime. {initialTimeOnPath} += {timeTillStartLerp}");
                            startTimeOnPath += spinTimerCurrent - startTimeOnPath;
                        }
                    }
                    else
                    {
                        //Debug.Log($"Adding amountToTraverseDuringStep {amountToTraverseDuringStep} * ((float)(spinTimerCurrent{spinTimerCurrent}/lerpOverTime{lerpOverTime})){(spinTimerCurrent / lerpOverTime)} = {amountToTraverseDuringStep * (spinTimerCurrent / lerpOverTime)} being added to output {output.ToString()}");
                        output += amountToTraverseDuringStep * ((spinTimerCurrent - startTimeOnPath) / activeLerpTimeToCompleteStep);
                        startTimeOnPath += spinTimerCurrent - startTimeOnPath;
                    }
                }
                if(Mathf.Abs(output.sqrMagnitude) >Mathf.Abs(pathPositions.path[pathPositions.path.Length - 1].sqrMagnitude))
                {
                    while (Mathf.Abs(output.sqrMagnitude) > Mathf.Abs(pathPositions.path[pathPositions.path.Length - 1].sqrMagnitude))
                    {
                        output -= pathPositions.path[0];
                        //Increment times reached end of path for each time end of path is reached
                        timesReachedEndOfPath += 1;
                    }
                }
            }
            else //Set to end position on path and return value
            {
                int positionIndex = pathPositions.startPosition + stepsPerSpin;
                if (positionIndex >= pathPositions.path.Length)
                {
                    while (positionIndex >= pathPositions.path.Length)
                    {
                        timesReachedEndOfPath += 1;
                        positionIndex -= (pathPositions.path.Length - 1);
                    }
                }
                output = pathPositions.path[positionIndex];
            }
        }
        if (timesReachedEndOfPath != pathPositions.timesReachedEndOfPath)
        {
            pathPositions.timesReachedEndOfPath = timesReachedEndOfPath;
            pathPositions.changeSymbolGraphic = true;
        }
        //Need to calculate time till end of path
        pathPositions.toPositionEvaluated = output;
        return output;
    }

    internal override float GetTotalTime()
    {
        //Only returns amount to take for 1 step - calling object needs to multiply by point to point in path array Length-1;
        return (activeLerpTimeToCompleteStep + pauseBetweenStepsFor);
    }

    internal override bool isTimeInPauseState(float spinCurrentTimer)
    {
        float tempTimer = 0;
        bool addActiveTimerAmount = true;
        //Add active time and inactive time until time is > current time
        while (tempTimer < spinCurrentTimer)
        {
            tempTimer += addActiveTimerAmount ? activeLerpTimeToCompleteStep : pauseBetweenStepsFor;
            addActiveTimerAmount = !addActiveTimerAmount;
        }
        //Last added time was active - the time passed is in active state
        return !addActiveTimerAmount;
    }
}