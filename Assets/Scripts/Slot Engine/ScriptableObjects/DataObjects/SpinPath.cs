//
//
//  Generated by StarUML(tm) C# Add-In
//
//  @ Project : Slot Engine
//  @ File Name : SlotEngine.cs
//  @ Date : 5/7/2014
//  @ Author : Evan McCall
//
//
using System;
using UnityEngine;

/// <summary>
/// 2 points in a path that connect - standard variables accesible for Path Spin Evaluations - distance is the necessary component 
/// </summary>
[Serializable]
public struct SpinPath
{
    /// <summary>
    /// Start Point in Path
    /// </summary>
    [SerializeField]
    public Vector3[] path;
    /// <summary>
    /// Size of the slot - used to determine amount to move for stepper
    /// </summary>
    [SerializeField]
    public Vector3 slotSize;
    /// <summary>
    /// Padding for slot - used to determine amount to move for stepper
    /// </summary>
    [SerializeField]
    public Vector3 slotPadding;
    /// <summary>
    /// tells the calling object whether to change symbol graphic
    /// </summary>
    [SerializeField]
    public bool changeSymbolGraphic;
    /// <summary>
    /// The starting position evaluating position on path from
    /// </summary>
    [SerializeField]
    public int startPosition;
    /// <summary>
    /// The amount of times objects has reached end of path before - used to evaluate whether to change symbol
    /// </summary>
    [SerializeField]
    public int timesReachedEndOfPath;
    /// <summary>
    /// toPosition Evaluated when ran thru an Evaluator
    /// </summary>
    [SerializeField]
    public Vector3 toPositionEvaluated;
    /// <summary>
    /// Iterate through path and return sqr magnitude between each position in path: Todo refactor on 
    /// </summary>
    [SerializeField]
    private float _totalAbsSqrMagnitudeOfPath;
    internal Vector3 distanceFirstLastPositionInPath;

    /// <summary>
    /// global reference for total sqr - will rebuild if initial = 0;
    /// </summary>
    public float totalAbsSqrMagnitudeOfPath
    {
        get
        {
            if (_totalAbsSqrMagnitudeOfPath == 0)
            {
                _totalAbsSqrMagnitudeOfPath = SetTotalAbsSqrMagnitudeOfPath();
            }
            return _totalAbsSqrMagnitudeOfPath;
        }
    }
    /// <summary>
    /// Takes in the path and auto calculates the total sqr magnitude required for evaluating distance to travel on spin
    /// </summary>
    /// <param name="path"></param>
    public SpinPath(Vector3[] path, int startPosition, Vector3 slotSize, Vector3 slotPadding)
    {
        this.path = path;
        this.startPosition = startPosition;
        this.timesReachedEndOfPath = 0;
        this.slotSize = slotSize;
        this.slotPadding = slotPadding;
        changeSymbolGraphic = false;
        toPositionEvaluated = Vector3.zero;
        float totalAbsSqrMagnitudePath = 0;
        //Debug.Log($"path length = {path.Length}");
        //Find distance between each point in path. end 1 iteration early - compare 2nd to last and last
        for (int point = 1; point < path.Length; point++)
        {
            //Debug.Log($"determining point {point} and {point - 1} path total length = {path.Length}");
            totalAbsSqrMagnitudePath += Mathf.Abs((path[point - 1] - path[point]).sqrMagnitude);
        }
        _totalAbsSqrMagnitudeOfPath = totalAbsSqrMagnitudePath;
        distanceFirstLastPositionInPath = path[0] - path[path.Length - 1];
    }
   

    private float SetTotalAbsSqrMagnitudeOfPath()
    {
        float output = 0;
        //Find distance between each point in path. end 1 iteration early - compare 2nd to last and last
        for (int point = 0; point < path.Length - 1; point++)
        {
            output += Mathf.Abs((path[point - 1] - path[point]).sqrMagnitude);
        }
        return output;
    }

    internal float ReturnSqrMagnitudeToNextPointInPath(int startPositionInPath)
    {
        if(startPositionInPath >= 0 && startPositionInPath < path.Length-1)
        {
            return (path[startPositionInPath + 1] - path[startPositionInPath]).sqrMagnitude;
        }
        else
        {
            Debug.LogWarning($"position in path supplied is end position or greater {startPositionInPath}");
            return 0;
        }
    }
}
    